{"version":3,"file":"helpers-analistas.js","sourceRoot":"","sources":["../../../src/shared/helpers/helpers-analistas.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,eAAe,EAAE,MAAM,GAAG,CAAC;AAMpC,MAAM,UAAU,WAAW,CACzB,QAAgC,EAChC,KAAa;IAEb,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;AAC/C,CAAC;AAKD,MAAM,UAAU,aAAa,CAAI,KAA6B;IAC5D,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;AAC3C,CAAC;AAaD,MAAM,UAAU,2BAA2B,CAAC,IAAsB;IAChE,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,YAAY,KAAK;QACzC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO;QACnB,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAEtB,OAAO,eAAe,CAAC;QACrB,IAAI,EAAE,eAAe;QACrB,KAAK,EAAE,OAAO;QACd,QAAQ,EAAE,oBAAoB,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE;QACtD,OAAO,EAAE,IAAI,CAAC,OAAO;QACrB,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,CAAC;QACtB,MAAM,EAAE,IAAI,CAAC,IAAI;KAClB,CAAC,CAAC;AACL,CAAC;AAMD,MAAM,UAAU,yBAAyB,CACvC,EAAW,EACX,YAAoB,EACpB,OAAe,EACf,YAAoB,CAAC;IAErB,IAAI,CAAC;QACH,OAAO,EAAE,EAAE,CAAC;IACd,CAAC;IAAC,OAAO,IAAI,EAAE,CAAC;QACd,OAAO,CAAC,2BAA2B,CAAC;gBAClC,IAAI,EAAE,YAAY;gBAClB,OAAO;gBACP,IAAI;gBACJ,KAAK,EAAE,SAAS;aACjB,CAAC,CAAM,CAAC;IACX,CAAC;AACH,CAAC;AAMD,MAAM,CAAC,KAAK,UAAU,8BAA8B,CAClD,EAAoB,EACpB,YAAoB,EACpB,OAAe,EACf,YAAoB,CAAC;IAErB,IAAI,CAAC;QACH,OAAO,MAAM,EAAE,EAAE,CAAC;IACpB,CAAC;IAAC,OAAO,IAAI,EAAE,CAAC;QACd,OAAO,CAAC,2BAA2B,CAAC;gBAClC,IAAI,EAAE,YAAY;gBAClB,OAAO;gBACP,IAAI;gBACJ,KAAK,EAAE,SAAS;aACjB,CAAC,CAAM,CAAC;IACX,CAAC;AACH,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT-0\n// Helpers utilitários para analistas\n\nimport type { Ocorrencia } from '@';\nimport { criarOcorrencia } from '@';\n\n/**\n * Incrementa um contador de ocorrências por chave.\n */\n\nexport function incrementar(\n  contador: Record<string, number>,\n  chave: string,\n): void {\n  contador[chave] = (contador[chave] ?? 0) + 1;\n}\n\n/**\n * Garante que sempre retorna array vazio se valor for null/undefined.\n */\nexport function garantirArray<T>(valor: T[] | null | undefined): T[] {\n  return Array.isArray(valor) ? valor : [];\n}\n\nexport interface ErroAnalistaInfo {\n  nome: string;\n  relPath: string;\n  erro: unknown;\n  linha?: number;\n}\n\n/**\n * Cria uma ocorrência de erro de análise padronizada.\n * Garante que erros de analista não quebrem a execução.\n */\nexport function criarOcorrenciaErroAnalista(info: ErroAnalistaInfo): Ocorrencia {\n  const mensagem = info.erro instanceof Error\n    ? info.erro.message\n    : String(info.erro);\n\n  return criarOcorrencia({\n    tipo: 'erro-analista',\n    nivel: 'aviso',\n    mensagem: `Erro no analista ${info.nome}: ${mensagem}`,\n    relPath: info.relPath,\n    linha: info.linha ?? 1,\n    origem: info.nome\n  });\n}\n\n/**\n * Wrapper para executar função de analista com tratamento de erros consistente.\n * Sempre retorna array vazio em vez de lançar exceção.\n */\nexport function executarComTratamentoErro<T extends Ocorrencia[]>(\n  fn: () => T,\n  nomeAnalista: string,\n  relPath: string,\n  linhaErro: number = 1\n): T {\n  try {\n    return fn();\n  } catch (erro) {\n    return [criarOcorrenciaErroAnalista({\n      nome: nomeAnalista,\n      relPath,\n      erro,\n      linha: linhaErro\n    })] as T;\n  }\n}\n\n/**\n * Wrapper async para executar função de analista com tratamento de erros consistente.\n * Sempre retorna array vazio em vez de lançar exceção.\n */\nexport async function executarAsyncComTratamentoErro<T extends Ocorrencia[]>(\n  fn: () => Promise<T>,\n  nomeAnalista: string,\n  relPath: string,\n  linhaErro: number = 1\n): Promise<T> {\n  try {\n    return await fn();\n  } catch (erro) {\n    return [criarOcorrenciaErroAnalista({\n      nome: nomeAnalista,\n      relPath,\n      erro,\n      linha: linhaErro\n    })] as T;\n  }\n}\n"]}