{"version":3,"file":"analista-funcoes-longas.js","sourceRoot":"","sources":["../../../src/analistas/js-ts/analista-funcoes-longas.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,MAAM,EAAE,MAAM,wBAAwB,CAAC;AAChD,OAAO,EAAE,uBAAuB,EAAE,MAAM,6BAA6B,CAAC;AAGtE,OAAO,EAAE,aAAa,EAAE,WAAW,EAAE,MAAM,GAAG,CAAC;AAE/C,SAAS,UAAU,CAAC,CAAU;IAC5B,OAAO,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,IAAI,IAAI,MAAM,IAAI,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,OAAQ,CAE1F,CAAC,QAAQ,KAAK,UAAU,CAAC;AAC7B,CAAC;AACD,MAAM,aAAa,GAAG,MAAM,CAAC,eAAe,EAAE,cAAc,EAAE,UAAU,IAAI,EAAE,CAAC;AAC/E,MAAM,iBAAiB,GAAG,MAAM,CAAC,eAAe,EAAE,cAAc,EAAE,cAAc,IAAI,CAAC,CAAC;AACtF,MAAM,kBAAkB,GAAG,MAAM,CAAC,eAAe,EAAE,cAAc,EAAE,eAAe,IAAI,CAAC,CAAC;AACxF,MAAM,CAAC,MAAM,qBAAqB,GAAG,aAAa,CAAC;IACjD,OAAO,CAAC,GAAW,EAAE,OAAe,EAAE,GAAiC,EAAE,SAAkB;QAEzF,MAAM,eAAe,GAAG,uBAAuB,CAAC;YAC9C,OAAO,EAAE,OAAO;YAChB,QAAQ,EAAE,GAAG;YACb,OAAO;SACR,CAAC,CAAC;QAGH,MAAM,gBAAgB,GAAG;YACvB,MAAM,EAAE,eAAe,CAAC,MAAM,IAAI,eAAe,CAAC,cAAc,CAAC,CAAC,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC,aAAa;YACpG,UAAU,EAAE,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC,iBAAiB;YAC9E,WAAW,EAAE,kBAAkB;SAChC,CAAC;QACF,MAAM,WAAW,GAAiB,EAAE,CAAC;QACrC,MAAM,cAAc,GAAG,CAAC,IAAwB,EAAE,KAAuC,EAAE,KAAa,EAAE,QAAgB,EAAE,EAAE;YAC5H,WAAW,CAAC,IAAI,CAAC;gBACf,IAAI;gBACJ,KAAK;gBACL,OAAO;gBACP,OAAO,EAAE,OAAO;gBAChB,KAAK;gBACL,QAAQ;gBACR,MAAM,EAAE,yBAAyB;aAClC,CAAC,CAAC;QACL,CAAC,CAAC;QACF,SAAS,QAAQ,CAAC,EAAoB,EAAE,eAAuB,CAAC;YAC9D,MAAM,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC;YACnB,IAAI,CAAC,GAAG,IAAI,OAAO,GAAG,CAAC,KAAK,KAAK,QAAQ,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,QAAQ,IAAI,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;gBAC1M,OAAO;YACT,CAAC;YACD,MAAM,SAAS,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC;YACjC,MAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC;YAC7B,MAAM,MAAM,GAAG,OAAO,GAAG,SAAS,GAAG,CAAC,CAAC;YACvC,IAAI,MAAM,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC;gBACrC,cAAc,CAAC,cAAc,EAAE,OAAO,EAAE,SAAS,EAAE,cAAc,MAAM,iBAAiB,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC;YACtH,CAAC;YACD,MAAM,SAAS,GAAG,EAAE,CAAC,MAAM,CAAC;YAC5B,IAAI,SAAS,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,MAAM,GAAG,gBAAgB,CAAC,UAAU,EAAE,CAAC;gBAC5F,cAAc,CAAC,mBAAmB,EAAE,OAAO,EAAE,SAAS,EAAE,iCAAiC,SAAS,CAAC,MAAM,UAAU,gBAAgB,CAAC,UAAU,GAAG,CAAC,CAAC;YACrJ,CAAC;YAGD,IAAI,YAAY,GAAG,gBAAgB,CAAC,WAAW,EAAE,CAAC;gBAChD,cAAc,CAAC,iBAAiB,EAAE,OAAO,EAAE,SAAS,EAAE,4BAA4B,YAAY,UAAU,gBAAgB,CAAC,WAAW,GAAG,CAAC,CAAC;YAC3I,CAAC;YAGD,IAAI,EAAE,CAAC,eAAe,IAAI,IAAI,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACvG,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;oBAE5B,cAAc,CAAC,uBAAuB,EAAE,MAAM,EAAE,SAAS,EAAE,8BAA8B,CAAC,CAAC;gBAC7F,CAAC;YACH,CAAC;QACH,CAAC;QACD,SAAS,iBAAiB,CAAC,IAA2B,EAAE,cAAsB,CAAC;YAC7E,MAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAY,CAAC;YACzD,MAAM,IAAI,GAAI,IAEZ,CAAC,IAAI,CAAC;YACR,IAAI,IAAI,KAAK,qBAAqB,IAAI,IAAI,KAAK,oBAAoB,IAAI,IAAI,KAAK,yBAAyB,EAAE,CAAC;gBAE1G,MAAM,MAAM,GAAG,IAAmC,CAAC;gBACnD,QAAQ,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;gBAC9B,WAAW,EAAE,CAAC;YAChB,CAAC;YACD,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,QAAQ,KAAK,UAAU,EAAE,CAAC;gBAC5D,IAAI,CAAC,QAAQ,CAAC;oBACZ,mBAAmB,CAAC,CAAiB;wBACnC,iBAAiB,CAAC,CAAC,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC;oBACxC,CAAC;oBACD,kBAAkB,CAAC,CAAiB;wBAClC,iBAAiB,CAAC,CAAC,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC;oBACxC,CAAC;oBACD,uBAAuB,CAAC,CAAiB;wBACvC,iBAAiB,CAAC,CAAC,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC;oBACxC,CAAC;iBACF,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAID,IAAI,GAAG,IAAI,OAAQ,GAEjB,CAAC,QAAQ,KAAK,UAAU,EAAE,CAAC;YAC3B,iBAAiB,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YAC1B,OAAO,WAAW,CAAC;QACrB,CAAC;QAGD,MAAM,OAAO,GAAG,GAAiC,CAAC;QAClD,IAAI,QAAQ,GAAoB,IAAI,CAAC;QACrC,IAAI,CAAC;YACH,IAAI,OAAO,EAAE,CAAC;gBACZ,MAAM,EAAE,GAAG,OAAkB,CAAC;gBAC9B,IAAI,EAAE,IAAI,OAAO,EAAE,KAAK,QAAQ,EAAE,CAAC;oBACjC,MAAM,SAAS,GAAI,EAEjB,CAAC,IAAI,CAAC;oBACR,IAAI,SAAS,IAAI,OAAO,SAAS,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAE,SAE/D,CAAC,IAAI,CAAC,EAAE,CAAC;wBACT,QAAQ,GAAG,SAAqB,CAAC;oBACnC,CAAC;yBAAM,IAAI,KAAK,CAAC,OAAO,CAAE,EAExB,CAAC,IAAI,CAAC,EAAE,CAAC;wBACT,QAAQ,GAAG,OAAO,CAAC;oBACrB,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;QAAC,MAAM,CAAC;YACP,QAAQ,GAAG,IAAI,CAAC;QAClB,CAAC;QACD,IAAI,QAAQ,EAAE,CAAC;YACb,MAAM,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;YAC/D,KAAK,MAAM,KAAK,IAAI,IAAI,EAAE,CAAC;gBACzB,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAE,KAE1C,CAAC,IAAI,KAAK,qBAAqB,IAAK,KAEpC,CAAC,IAAI,KAAK,oBAAoB,IAAK,KAEnC,CAAC,IAAI,KAAK,yBAAyB,CAAC,EAAE,CAAC;oBACvC,QAAQ,CAAC,KAAyB,EAAE,CAAC,CAAC,CAAC;gBACzC,CAAC;YACH,CAAC;YACD,OAAO,WAAW,CAAC;QACrB,CAAC;QAGD,OAAO,WAAW,CAAC;IACrB,CAAC;IACD,IAAI,EAAE,yBAAyB;IAC/B,SAAS,EAAE,cAAc;IACzB,SAAS,EAAE,8FAA8F;IACzG,OAAO,EAAE;QACP,MAAM,EAAE,aAAa;QACrB,MAAM,EAAE,iBAAiB;QACzB,WAAW,EAAE,kBAAkB;KAChC;IACD,IAAI,EAAE,CAAC,OAAe,EAAW,EAAE,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;IACtF,MAAM,EAAE,KAAK;CACd,CAAC,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT-0\nimport type { NodePath } from '@babel/traverse';\nimport type { Node } from '@babel/types';\nimport { config } from '@core/config/config.js';\nimport { detectarContextoProjeto } from '@shared/contexto-projeto.js';\n\nimport type { FileLike, FunctionLikeNode, Ocorrencia } from '@';\nimport { criarAnalista, isBabelNode } from '@';\n\nfunction isNodePath(x: unknown): x is NodePath<Node> {\n  return typeof x === 'object' && x !== null && 'node' in x && isBabelNode(x.node) && typeof (x as {\n    traverse?: unknown;\n  }).traverse === 'function';\n}\nconst LIMITE_LINHAS = config.ANALISE_LIMITES?.FUNCOES_LONGAS?.MAX_LINHAS ?? 30;\nconst LIMITE_PARAMETROS = config.ANALISE_LIMITES?.FUNCOES_LONGAS?.MAX_PARAMETROS ?? 4;\nconst LIMITE_ANINHAMENTO = config.ANALISE_LIMITES?.FUNCOES_LONGAS?.MAX_ANINHAMENTO ?? 3;\nexport const analistaFuncoesLongas = criarAnalista({\n  aplicar(src: string, relPath: string, ast: NodePath<Node> | Node | null, _fullPath?: string) {\n    // Aplicar contexto inteligente\n    const contextoArquivo = detectarContextoProjeto({\n      arquivo: relPath,\n      conteudo: src,\n      relPath\n    });\n\n    // Limites mais relaxados para testes e configurações\n    const limitesAjustados = {\n      linhas: contextoArquivo.isTest || contextoArquivo.isConfiguracao ? LIMITE_LINHAS * 2 : LIMITE_LINHAS,\n      parametros: contextoArquivo.isTest ? LIMITE_PARAMETROS + 2 : LIMITE_PARAMETROS,\n      aninhamento: LIMITE_ANINHAMENTO\n    };\n    const ocorrencias: Ocorrencia[] = [];\n    const pushOcorrencia = (tipo: Ocorrencia['tipo'], nivel: NonNullable<Ocorrencia['nivel']>, linha: number, mensagem: string) => {\n      ocorrencias.push({\n        tipo,\n        nivel,\n        relPath,\n        arquivo: relPath,\n        linha,\n        mensagem,\n        origem: 'analista-funcoes-longas'\n      });\n    };\n    function analisar(fn: FunctionLikeNode, _aninhamento: number = 0): void {\n      const loc = fn.loc;\n      if (!loc || typeof loc.start !== 'object' || typeof loc.end !== 'object' || typeof loc.start.line !== 'number' || typeof loc.end.line !== 'number' || loc.start.line < 1 || loc.end.line < loc.start.line) {\n        return;\n      }\n      const startLine = loc.start.line;\n      const endLine = loc.end.line;\n      const linhas = endLine - startLine + 1;\n      if (linhas > limitesAjustados.linhas) {\n        pushOcorrencia('FUNCAO_LONGA', 'aviso', startLine, `Função com ${linhas} linhas (máx: ${limitesAjustados.linhas})`);\n      }\n      const paramsArr = fn.params;\n      if (paramsArr && Array.isArray(paramsArr) && paramsArr.length > limitesAjustados.parametros) {\n        pushOcorrencia('MUITOS_PARAMETROS', 'aviso', startLine, `Função com muitos parâmetros (${paramsArr.length}, máx: ${limitesAjustados.parametros})`);\n      }\n\n      // Verifica se a função está aninhada demais\n      if (_aninhamento > limitesAjustados.aninhamento) {\n        pushOcorrencia('FUNCAO_ANINHADA', 'aviso', startLine, `Função aninhada em nível ${_aninhamento} (máx: ${limitesAjustados.aninhamento})`);\n      }\n\n      // Verifica se a função não tem comentário - menos rigoroso para testes\n      if (fn.leadingComments == null || Array.isArray(fn.leadingComments) && fn.leadingComments.length === 0) {\n        if (!contextoArquivo.isTest) {\n          // Testes não precisam comentários obrigatórios\n          pushOcorrencia('FUNCAO_SEM_COMENTARIO', 'info', startLine, `Função sem comentário acima.`);\n        }\n      }\n    }\n    function analisarRecursivo(path: NodePath<Node> | Node, aninhamento: number = 0) {\n      const node = isNodePath(path) ? path.node : path as Node;\n      const type = (node as {\n        type?: string;\n      }).type;\n      if (type === 'FunctionDeclaration' || type === 'FunctionExpression' || type === 'ArrowFunctionExpression') {\n        // garantir que 'node' atenda à forma mínima esperada por analisar\n        const fnNode = node as unknown as FunctionLikeNode;\n        analisar(fnNode, aninhamento);\n        aninhamento++;\n      }\n      if (isNodePath(path) && typeof path.traverse === 'function') {\n        path.traverse({\n          FunctionDeclaration(p: NodePath<Node>) {\n            analisarRecursivo(p, aninhamento + 1);\n          },\n          FunctionExpression(p: NodePath<Node>) {\n            analisarRecursivo(p, aninhamento + 1);\n          },\n          ArrowFunctionExpression(p: NodePath<Node>) {\n            analisarRecursivo(p, aninhamento + 1);\n          }\n        });\n      }\n    }\n\n    // --- Fluxo centralizado e robusto ---\n    // 1. NodePath real: use traverse e recursão\n    if (ast && typeof (ast as unknown as {\n      traverse?: unknown;\n    }).traverse === 'function') {\n      analisarRecursivo(ast, 0);\n      return ocorrencias;\n    }\n\n    // 2. AST puro ou mock: só processa body do File, nunca recursiona\n    const fileAst = ast as unknown as FileLike | null;\n    let fileNode: FileLike | null = null;\n    try {\n      if (fileAst) {\n        const fa = fileAst as unknown;\n        if (fa && typeof fa === 'object') {\n          const maybeNode = (fa as {\n            node?: unknown;\n          }).node;\n          if (maybeNode && typeof maybeNode === 'object' && Array.isArray((maybeNode as {\n            body?: unknown;\n          }).body)) {\n            fileNode = maybeNode as FileLike;\n          } else if (Array.isArray((fa as {\n            body?: unknown;\n          }).body)) {\n            fileNode = fileAst;\n          }\n        }\n      }\n    } catch {\n      fileNode = null;\n    }\n    if (fileNode) {\n      const body = Array.isArray(fileNode.body) ? fileNode.body : [];\n      for (const child of body) {\n        if (child && typeof child === 'object' && ((child as {\n          type?: string;\n        }).type === 'FunctionDeclaration' || (child as {\n          type?: string;\n        }).type === 'FunctionExpression' || (child as {\n          type?: string;\n        }).type === 'ArrowFunctionExpression')) {\n          analisar(child as FunctionLikeNode, 0);\n        }\n      }\n      return ocorrencias;\n    }\n\n    // Se não for nenhum dos casos acima, retorna vazio\n    return ocorrencias;\n  },\n  nome: 'analista-funcoes-longas',\n  categoria: 'complexidade',\n  descricao: 'Detecta funcoes muito longas, com muitos parametros, aninhamento excessivo ou sem comentario',\n  limites: {\n    linhas: LIMITE_LINHAS,\n    params: LIMITE_PARAMETROS,\n    aninhamento: LIMITE_ANINHAMENTO\n  },\n  test: (relPath: string): boolean => relPath.endsWith('.js') || relPath.endsWith('.ts'),\n  global: false\n});"]}