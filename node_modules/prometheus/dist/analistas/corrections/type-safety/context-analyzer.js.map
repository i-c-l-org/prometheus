{"version":3,"file":"context-analyzer.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/context-analyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n// @prometheus-disable problema-documentacao\n// Justificativa: funções estão tipadas, detector está identificando falsos positivos\n/**\n * Analisador de contexto para Type Safety Auto-Fix\n * Detecta contextos onde any/unknown NÃO devem ser modificados\n */\n\n/**\n * Verifica se posição está dentro de string literal\n *\n * IMPORTANTE: Normaliza line endings para garantir compatibilidade Windows/Linux.\n * Sem isso, arquivos com \\r\\n podem causar problemas de parsing.\n *\n * Ver: docs/reports/DEBUG-TYPE-SAFETY-DETECTOR-2025-11-03.md\n */\n/**\n * Categoriza uso de unknown com nível de confiança\n * Retorna: 'legitimo' | 'melhoravel' | 'corrigir' + confiança (0-100)\n */\nimport type { CategorizacaoUnknown } from '@';\n\nexport function isInString(code: string, position: number): boolean {\n  // Normaliza line endings para \\n (Windows compatibility)\n  const normalizedCodigo = code.replace(/\\r\\n/g, '\\n');\n  const before = normalizedCodigo.substring(0, position);\n\n  // Conta aspas simples, duplas e template strings\n  const singleQuotesBefore = (before.match(/(?<!\\\\)'/g) || []).length;\n  const doubleQuotesBefore = (before.match(/(?<!\\\\)\"/g) || []).length;\n  const templateQuotesBefore = (before.match(/(?<!\\\\)`/g) || []).length;\n\n  // Se número ímpar de aspas antes, está dentro de string\n  return singleQuotesBefore % 2 === 1 || doubleQuotesBefore % 2 === 1 || templateQuotesBefore % 2 === 1;\n}\n\n/**\n * Verifica se posição está dentro de comentário\n *\n * CORREÇÕES APLICADAS (2025-11-03):\n * 1. Normalização de line endings (\\r\\n → \\n) para Windows/Linux\n * 2. Lógica corrigida: só marca como comentário se posição está DEPOIS do //\n *    Antes: verificava apenas se havia // na linha (marcava tudo)\n *    Depois: verifica se posInLine >= commentStart\n *\n * Casos de teste:\n * - \"// comentário\\nconst x = 5;\" → linha 2 NÃO está em comentário ✅\n * - \"const x = 5; // comentário\" → \"const x = 5\" NÃO está em comentário ✅\n * - \"const x = 5; // comentário\" → \"// comentário\" ESTÁ em comentário ✅\n *\n * Ver: docs/reports/DEBUG-TYPE-SAFETY-DETECTOR-2025-11-03.md\n */\nexport function isInComment(code: string, position: number): boolean {\n  // Normaliza line endings para \\n (Windows compatibility)\n  const normalizedCodigo = code.replace(/\\r\\n/g, '\\n');\n  const lines = normalizedCodigo.split('\\n');\n  let pos = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineInicio = pos;\n    const lineFim = pos + line.length;\n    if (position >= lineInicio && position <= lineFim) {\n      // Verifica comentário inline (//)\n      // A posição relativa na linha\n      const posInLine = position - lineInicio;\n      const commentInicio = line.indexOf('//');\n\n      // Se há // na linha E a posição está depois do //, está em comentário\n      if (commentInicio !== -1 && posInLine >= commentInicio) {\n        return true;\n      }\n\n      // Verifica comentário de bloco (/* */)\n      const blockInicio = normalizedCodigo.lastIndexOf('/*', position);\n      const blockFim = normalizedCodigo.indexOf('*/', position);\n      if (blockInicio !== -1 && (blockFim === -1 || blockFim > position)) {\n        return true;\n      }\n      return false;\n    }\n    pos = lineFim + 1; // +1 para o \\n\n  }\n  return false;\n} /**\n  * Verifica se posição está em string ou comentário\n  */\nexport function isInStringOrComment(code: string, position: number): boolean {\n  return isInString(code, position) || isInComment(code, position);\n}\n\n/**\n * Verifica se está em contexto TypeScript específico que deve ser ignorado\n * Exemplos: type annotation em interface, generic constraints, etc\n *\n * IMPORTANTE: NÃO ignora type assertions (as any) - esses são CRÍTICOS\n * e devem ser detectados separadamente como tipo-inseguro-any-assertion.\n *\n * CORREÇÃO APLICADA (2025-11-03):\n * Removida detecção de `as any` que estava ignorando type assertions.\n * Type assertions NÃO são legítimos - são exatamente o que queremos detectar!\n *\n * Ver: docs/reports/DEBUG-TYPE-SAFETY-DETECTOR-2025-11-03.md\n */\nexport function isTypeScriptContext(code: string, position: number): boolean {\n  const context = code.substring(Math.max(0, position - 50), position + 50);\n\n  // NÃO ignorar type assertions - eles são CRÍTICOS e detectados separadamente\n  // O código abaixo foi removido para que as type assertions sejam sempre detectadas\n\n  // Tipo de retorno de função genérica (isso ainda pode ser legítimo em alguns casos)\n  if (/<[^>]*>\\s*\\([^)]*\\)\\s*:\\s*(any|unknown)/.test(context)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Verifica se é arquivo legado ou vendor\n */\nexport function isLegacyOrVendorFile(fileCaminho?: string): boolean {\n  if (!fileCaminho) return false;\n  const legacyPadroes = ['/legacy/', '/legado/', '/vendor/', '/node_modules/', '/dist/', '/build/', '.d.ts', '.min.js'];\n  return legacyPadroes.some(pattern => fileCaminho.includes(pattern));\n}\n\n/**\n * Verifica se unknown está sendo usado em contexto apropriado\n * Contextos apropriados: entrada genérica, APIs externas, deserialização\n */\nexport function isUnknownInGenericContext(code: string, position: number): boolean {\n  const context = code.substring(Math.max(0, position - 200), position + 100);\n\n  // Função genérica com tipo T\n  if (/function\\s+\\w+<T[^>]*>/.test(context)) {\n    return true;\n  }\n\n  // Deserialização (JSON.parse, etc)\n  if (/JSON\\.parse|deserialize|decode/.test(context)) {\n    return true;\n  }\n\n  // API externa ou fetch\n  if (/fetch|axios|request|response\\.data/.test(context)) {\n    return true;\n  }\n\n  // Funções de persistência/serialização que aceitam dados genéricos\n  if (/salvar|persist|save|store|write.*:\\s*\\([^)]*dados:\\s*unknown/.test(context)) {\n    return true;\n  }\n\n  // Record<string, unknown> - padrão legítimo para objetos genéricos\n  if (/Record<\\s*string\\s*,\\s*unknown\\s*>/.test(context)) {\n    return true;\n  }\n\n  // Array<unknown> ou unknown[] - arrays genéricos\n  if (/Array<\\s*unknown\\s*>|unknown\\s*\\[\\]/.test(context)) {\n    return true;\n  }\n\n  // Parâmetros opcionais genéricos (estilo?: unknown, options?: unknown)\n  if (/\\w+\\?\\s*:\\s*unknown/.test(context)) {\n    return true;\n  } // Type guard function que retorna type predicate\n  if (/function\\s+\\w+\\([^)]*:\\s*unknown\\)[^:]*:\\s*\\w+\\s+is\\s+\\w+/.test(context)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Verifica se any está em declaração de função genérica\n * Nesses casos, pode ser legítimo dependendo do contexto\n */\nexport function isAnyInGenericFunction(code: string, position: number): boolean {\n  const context = code.substring(Math.max(0, position - 300), position + 100);\n\n  // Função de callback genérica\n  if (/callback\\s*:\\s*\\([^)]*:\\s*any/.test(context)) {\n    return true;\n  }\n\n  // Event handler genérico\n  if (/on\\w+\\s*:\\s*\\([^)]*:\\s*any/.test(context)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Extrai domínio do arquivo baseado no caminho\n */\nexport function getDomainFromFilePath(fileCaminho: string): string {\n  const match = fileCaminho.match(/src\\/([\\w-]+)\\//);\n  if (match) {\n    return match[1];\n  }\n\n  // Fallback para 'shared' se não conseguir determinar\n  return 'shared';\n}\n\n/**\n * Converte PascalCase/camelCase para kebab-case\n */\nexport function toKebabCase(str: string): string {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[\\s_]+/g, '-').toLowerCase();\n}\n\n/**\n * Verifica se é arquivo de definição de tipos (.d.ts)\n */\nexport function isDefinitionFile(fileCaminho: string): boolean {\n  return fileCaminho.endsWith('.d.ts');\n}\n\n/**\n * Verifica se é arquivo TypeScript\n */\nexport function isTypeScriptFile(fileCaminho: string): boolean {\n  return fileCaminho.endsWith('.ts') || fileCaminho.endsWith('.tsx');\n}\n\n/**\n * Extrai nome da variável/parâmetro do match\n */\nexport function extractVariableName(match: RegExpMatchArray, code: string): string | null {\n  const position = match.index || 0;\n  const before = code.substring(Math.max(0, position - 100), position + match[0].length);\n\n  // Padrão: nome: any ou nome: unknown\n  const varMatch = before.match(/(\\w+)\\s*:\\s*(?:any|unknown)\\b/);\n  if (varMatch) {\n    return varMatch[1];\n  }\n  return null;\n}\n\n/**\n * Extrai contexto da linha onde o match ocorre\n */\nexport function extractLineContext(code: string, position: number): string {\n  const lines = code.split('\\n');\n  let pos = 0;\n  for (const line of lines) {\n    const lineInicio = pos;\n    const lineFim = pos + line.length;\n    if (position >= lineInicio && position <= lineFim) {\n      return line;\n    }\n    pos = lineFim + 1;\n  }\n  return '';\n}\n\n// Re-exporta para compatibilidade\nexport type { CategorizacaoUnknown };\nexport function categorizarUnknown(code: string, fileCaminho: string, lineContext: string): CategorizacaoUnknown {\n  // Type Guards - 100% legítimo\n  if (/:\\s*unknown\\)\\s*:\\s*\\w+\\s+is\\s+/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Type guard padrão TypeScript - unknown é a escolha correta'\n    };\n  }\n\n  // Catch blocks - 100% legítimo\n  if (/catch\\s*\\(\\s*\\w+\\s*:\\s*unknown\\s*\\)/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Catch block padrão TypeScript - unknown é recomendado'\n    };\n  }\n\n  // Índice extensível [k: string]: unknown - 100% legítimo\n  if (/\\[\\s*\\w+\\s*:\\s*string\\s*\\]\\s*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Índice extensível - permite propriedades adicionais'\n    };\n  }\n\n  // Record<string, unknown> ou Map<*, unknown> - 100% legítimo\n  if (/Record<[^,]+,\\s*unknown>/.test(lineContext) || /Map<[^,]+,\\s*unknown>/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Objeto genérico - Record/Map com unknown é apropriado'\n    };\n  }\n\n  // Array<unknown> ou unknown[] - 100% legítimo\n  if (/Array<unknown>/.test(lineContext) || /unknown\\[\\]/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Array genérico - unknown[] é apropriado'\n    };\n  }\n\n  // Parâmetro opcional com unknown - 95% legítimo\n  if (/\\w+\\?\\s*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Parâmetro opcional - unknown é aceitável',\n      sugestao: 'Considere usar tipo mais específico se o uso for conhecido'\n    };\n  }\n\n  // Guardian related - análise detalhada\n  if (/guardian\\s*:\\s*unknown/.test(lineContext) || fileCaminho.includes('guardian')) {\n    if (lineContext.includes('detalhes') || lineContext.includes('erros') || lineContext.includes('Error')) {\n      return {\n        categoria: 'corrigir',\n        confianca: 90,\n        motivo: 'Guardian error details tem estrutura conhecida',\n        sugestao: 'Criar interface GuardianErrorDetails com campos específicos',\n        variantes: ['interface GuardianErrorDetails { message: string; code?: string; stack?: string }', 'type GuardianError = Error | { message: string; details?: unknown }', 'Usar tipo Error nativo do TypeScript']\n      };\n    }\n    return {\n      categoria: 'melhoravel',\n      confianca: 85,\n      motivo: 'Guardian retorna dados não estruturados',\n      sugestao: 'Criar interface GuardianResult com campos conhecidos',\n      variantes: ['interface GuardianResult { status: \"ok\" | \"erro\"; baseline?: Baseline; drift?: Drift }', 'type GuardianOutput = SuccessResult | ErrorResult (discriminated union)', 'Usar zod/io-ts para validação runtime + tipos']\n    };\n  }\n\n  // AST/Babel nodes - 80% melhorável\n  if (/\\bast\\s*:\\s*unknown/.test(lineContext) || /\\bnode\\s*:\\s*unknown/.test(lineContext) || lineContext.includes('NodePath')) {\n    return {\n      categoria: 'melhoravel',\n      confianca: 80,\n      motivo: 'AST deveria ser tipado com Node do @babel/types',\n      sugestao: 'import type { Node } from \"@babel/types\"; usar Node | null',\n      variantes: ['Node (AST node genérico do Babel)', 'NodePath<Node> (para traverse)', 'File | Program | Statement | Expression (tipos específicos)']\n    };\n  }\n\n  // Funções de serialização/persistência - 95% legítimo\n  if (/salvar|persist|save|store|write|serialize|stringify/.test(lineContext) && /dados\\s*:\\s*unknown|value\\s*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Função de serialização - unknown é apropriado para dados genéricos',\n      sugestao: 'Se formato for conhecido, use tipo genérico: <T = unknown>(dados: T) => ...'\n    };\n  }\n\n  // Funções de validação genéricas - 95% legítimo\n  if (/validar|validate|check|assert|guard/.test(lineContext) && /\\w+\\s*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Função de validação - recebe unknown e valida tipo'\n    };\n  }\n\n  // Acesso dinâmico protegido (safeGet) - 95% legítimo\n  if (/safeGet|tryGet|getProperty/.test(lineContext) && /:\\s*unknown/.test(lineContext) && !/:\\s*unknown\\)/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Acesso dinâmico protegido - retorno é unknown por segurança',\n      sugestao: 'Validar tipo após obter valor: const val = safeGet(...); if (typeof val === ...)'\n    };\n  }\n\n  // Replacer functions em JSON - 95% legítimo\n  if (/replacer|reviver/.test(lineContext) && /\\w+\\s*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Replacer/reviver do JSON - unknown é esperado'\n    };\n  }\n\n  // Wrappers de AST/parsing - 95% legítimo\n  if (/wrap|parse|transform/.test(lineContext) && /ast\\s*:\\s*unknown|rawAst\\s*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Wrapper de parser - AST de origem desconhecida'\n    };\n  }\n\n  // Funções de error handling - 95% legítimo\n  if (/error\\s*:\\s*unknown|err\\s*:\\s*unknown|e\\s*:\\s*unknown/.test(lineContext) && (/extrair|extract|format|parse/.test(lineContext) || fileCaminho.includes('validacao'))) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Error handling - error pode ser de qualquer tipo em catch/callbacks'\n    };\n  }\n\n  // Mock/test utilities - 95% legítimo\n  if (/mock|vitest|expect|args\\s*:\\s*unknown\\[\\]/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Test utilities - tipos genéricos de framework de testes'\n    };\n  }\n\n  // CLI options/callbacks - 95% legítimo quando vem de framework\n  if (/opts\\s*:\\s*unknown|options\\s*:\\s*unknown/.test(lineContext) && (fileCaminho.includes('cli') || /aplicar|process|handle/.test(lineContext))) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'CLI framework callback - opts validado downstream'\n    };\n  }\n\n  // Propriedades de índice dinâmico em type assertions - 95% legítimo\n  if (/as\\s+unknown\\s+as\\s+\\{[^}]*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Type assertion para acesso dinâmico - padrão de compatibilidade'\n    };\n  }\n\n  // Callbacks/handlers genéricos - análise contextual\n  if (/(opts|options|params|args)\\s*:\\s*unknown/.test(lineContext)) {\n    if (fileCaminho.includes('cli') || fileCaminho.includes('comando')) {\n      return {\n        categoria: 'legitimo',\n        confianca: 85,\n        motivo: 'Callback CLI - opts será validado downstream',\n        sugestao: 'Considere tipar se a interface for conhecida',\n        variantes: ['CommandOptions (interface do commander.js)', 'Record<string, string | boolean | number> (CLI flags genéricos)', 'Usar zod schema para validação + inferência de tipos']\n      };\n    }\n    return {\n      categoria: 'melhoravel',\n      confianca: 70,\n      motivo: 'Parâmetro genérico - pode ser mais específico',\n      sugestao: 'Definir interface específica para os parâmetros',\n      variantes: ['interface FunctionOptions { timeout?: number; verbose?: boolean; ... }', 'Partial<KnownConfig> (se for subset de config)', 'Usar tipo genérico com constraint: <T extends BaseOptions>']\n    };\n  }\n\n  // Filter/map com unknown - 75% melhorável\n  if (/filter\\s*\\(/.test(lineContext) || /map\\s*\\(/.test(lineContext)) {\n    return {\n      categoria: 'melhoravel',\n      confianca: 75,\n      motivo: 'Array operation com tipo genérico - pode inferir tipo do array',\n      sugestao: 'Tipar o array pai para propagar tipos automaticamente',\n      variantes: ['Especificar tipo do array: items: Item[] em vez de items: unknown[]', 'Usar generics: function filter<T>(items: T[], predicate: (item: T) => boolean)', 'Inferir do contexto: const typed = items as KnownType[]']\n    };\n  }\n\n  // Relatórios/fragmentação - 70% melhorável\n  if (fileCaminho.includes('relatorio') || fileCaminho.includes('fragmentar') || lineContext.includes('Manifest')) {\n    return {\n      categoria: 'melhoravel',\n      confianca: 70,\n      motivo: 'Dados de relatório - estrutura pode ser definida',\n      sugestao: 'Criar interfaces específicas para estruturas de dados',\n      variantes: ['interface RelatorioCompleto { summary: Summary; detalhes: Detalhe[]; ... }', 'interface ManifestPart { id: string; tipo: string; conteudo: unknown }', 'type RelatorioJson = { version: string; data: Record<string, unknown> }']\n    };\n  }\n\n  // Compatibilidade de módulos - 95% legítimo\n  if (fileCaminho.includes('chalk-safe') || /import\\s*\\(/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Compatibilidade ESM/CJS - unknown necessário para imports dinâmicos',\n      sugestao: 'Pode adicionar type assertion após validação runtime'\n    };\n  }\n\n  // Análise de contexto amplo quando específico falha\n  const contextoAmplo = code.substring(Math.max(0, lineContext.length - 300), lineContext.length + 200);\n\n  // Verifica se há validação/type guard próximo\n  if (/typeof\\s+\\w+\\s*===/.test(contextoAmplo) || /instanceof/.test(contextoAmplo) || /is\\w+\\(/.test(contextoAmplo)) {\n    return {\n      categoria: 'melhoravel',\n      confianca: 65,\n      motivo: 'Há validação de tipo próxima - pode extrair para type guard dedicado',\n      sugestao: 'Criar função type guard: function isTipoX(obj: unknown): obj is TipoX { ... }',\n      variantes: ['Extrair validações para type guard reutilizável', 'Usar biblioteca de validação (zod, yup, io-ts) para runtime + types', 'Criar branded types se for validação complexa']\n    };\n  }\n\n  // Default: melhorável com análise incerta\n  return {\n    categoria: 'melhoravel',\n    confianca: 60,\n    motivo: 'Tipo unknown genérico - análise contextual limitada',\n    sugestao: 'Analisar fluxo de dados para inferir tipo correto',\n    variantes: ['Se vem de API externa: definir interface baseada na resposta esperada', 'Se é callback: especificar assinatura da função', 'Se é config/options: criar interface com campos opcionais', 'Se é polimórfico: considerar discriminated union ou generics']\n  };\n}"]}