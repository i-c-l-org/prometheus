{"version":3,"file":"autodiscovery.js","sourceRoot":"","sources":["../../../src/analistas/registry/autodiscovery.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n// @prometheus-disable PROBLEMA_PERFORMANCE\n// Justificativa: autodiscovery que varre arquivos - loops são necessários\nimport { promises as fs } from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n\nimport type { Analista, EntradaRegistry, ModuloAnalista, Tecnica } from '@';\n\ntype Entry = Analista | Tecnica;\n\nfunction isEntry(x: unknown): x is Entry {\n  if (!x || typeof x !== 'object') return false;\n  const o = x as Record<string, unknown>;\n  return typeof o.nome === 'string' && typeof o.aplicar === 'function';\n}\n\nfunction extrairEntradasDeModulo(mod: unknown): Entry[] {\n  const m = mod as ModuloAnalista & Record<string, unknown>;\n  const out: Entry[] = [];\n\n  const candidates: unknown[] = [];\n  candidates.push(m.default);\n  if (Array.isArray(m.analistas)) candidates.push(...m.analistas);\n\n  // Coleta exportações nomeadas que pareçam analista/técnica\n  for (const v of Object.values(m)) candidates.push(v);\n\n  for (const c of candidates) {\n    if (Array.isArray(c)) {\n      for (const item of c) if (isEntry(item)) out.push(item);\n      continue;\n    }\n    if (isEntry(c)) out.push(c);\n  }\n\n  // Dedup interno por nome\n  const byName = new Map<string, Entry>();\n  for (const e of out) {\n    if (e.nome) byName.set(e.nome, e);\n  }\n  return Array.from(byName.values());\n}\n\n/**\n * Autodiscovery de analistas/plugins.\n *\n * Convenção: qualquer arquivo em `src/analistas/plugins/` com prefixo\n * `analista-` ou `detector-` será importado e suas entradas serão extraídas.\n *\n * - Em runtime buildado: arquivos `.js`\n * - Em Vitest/dev: arquivos `.ts` podem existir (resolver do Vitest mapeia `.js` -> `.ts`)\n */\nexport async function discoverAnalistasPlugins(): Promise<EntradaRegistry[]> {\n  try {\n    const dirUrl = new URL('../plugins/', import.meta.url);\n    const dirFsPath = fileURLToPath(dirUrl);\n    const entries = await fs.readdir(dirFsPath, { withFileTypes: true });\n\n    const arquivos = entries\n      .filter((e) => e.isFile())\n      .map((e) => e.name)\n      .filter((n) => n !== 'index.ts' && n !== 'index.js')\n      .filter((n) => /^(analista|detector)-.+\\.(ts|js)$/i.test(n));\n\n    const results: EntradaRegistry[] = [];\n    for (const fname of arquivos) {\n      const base = fname.replace(/\\.(ts|js)$/i, '');\n      // Preferimos importar via alias com sufixo .js (forma padrão do código);\n      // em testes, o Vitest resolve este .js para o .ts correspondente.\n      const spec = `@analistas/plugins/${base}.js`;\n      try {\n        const mod = (await import(spec)) as unknown;\n        const extracted = extrairEntradasDeModulo(mod);\n        results.push(...extracted);\n      } catch {\n        // Fallback: tentar importar via caminho file:// direto para o arquivo encontrado\n        try {\n          const fileUrl = new URL(fname, dirUrl);\n          const mod2 = (await import(fileUrl.toString())) as unknown;\n          const extracted2 = extrairEntradasDeModulo(mod2);\n          results.push(...extracted2);\n        } catch {\n          // plugin opcional: ignorar\n        }\n      }\n    }\n\n    // Dedup final por nome\n    const byName = new Map<string, EntradaRegistry>();\n    for (const r of results) {\n      const entry = r as Entry;\n      if (entry?.nome) byName.set(entry.nome, r);\n    }\n    return Array.from(byName.values());\n  } catch {\n    return [];\n  }\n}\n\n"]}