{"version":3,"file":"analistas.js","sourceRoot":"","sources":["../../../src/types/comum/analistas.ts"],"names":[],"mappings":"AAQA,OAAO,EAAE,iBAAiB,EAAE,MAAM,0CAA0C,CAAC;AAiC7E,MAAM,UAAU,aAAa,CAAqB,GAAM;IACtD,IAAI,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ;QAAE,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,yBAAyB,CAAC,CAAC;IAClG,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,KAAK,KAAK,EAAE,CAAC;IAE3D,CAAC;IACD,IAAI,OAAO,GAAG,CAAC,OAAO,KAAK,UAAU;QAAE,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,wBAAwB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;IAC7G,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC5B,CAAC;AACD,MAAM,UAAU,UAAU,CAAC,IAAwB;IACjD,OAAO,MAAM,IAAI,IAAI,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;AACjF,CAAC;AACD,MAAM,UAAU,UAAU,CAAC,KAA6B;IACtD,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;QAErB,MAAM,IAAI,GAAG,GAAgD,CAAC;QAC9D,MAAM,IAAI,GAAG,IAAI,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAc,CAAC,CAAC,CAAC,mBAAmB,CAAC;QACvH,MAAM,MAAM,GAAG,IAAI,IAAI,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAA6B,CAAC,CAAC,CAAC,SAAS,CAAC;QACzF,MAAM,IAAI,GAAG,IAAI,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,IAA8B,CAAC,CAAC,CAAC,SAAS,CAAC;QAIvG,MAAM,OAAO,GAAG,IAAI,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,QAAgB,EAAE,OAAe,EAAE,GAAkB,EAAE,WAAoB,EAAE,cAA6C,EAAE,EAAE;YAChM,MAAM,QAAQ,GAAG,GAA6E,CAAC;YAC/F,MAAM,SAAS,GAAG,IAAI,CAAC,OAAwC,CAAC;YAChE,IAAI,CAAC;gBACH,MAAM,CAAC,GAAG,MAAM,SAAS,CAAC,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;gBACpF,OAAO,CAAC,CAAC;YACX,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACb,MAAM,QAAQ,GAAG,GAAG,YAAY,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBAElE,OAAO,CAAC;wBACN,QAAQ,EAAE,6BAA6B,IAAI,KAAK,QAAQ,EAAE;wBAC1D,KAAK,EAAE,MAAM;wBACb,OAAO;wBACP,KAAK,EAAE,CAAC;wBACR,IAAI,EAAE,qBAAqB;qBACF,CAAC,CAAC;YAC/B,CAAC;QACH,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC,EAAE,CAAC;QACnB,OAAO;YACL,IAAI;YACJ,MAAM;YACN,IAAI;YACJ,OAAO;SACe,CAAC;IAC3B,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT-0\n\n// PROMETHEUS: Revisar ocorrências 'unhandled-async' (1). Ver relatorio:\n// relatorios/prometheus-relatorio-summary-2026-02-24T22-21-50-731Z.json\n\n\nimport type { NodePath } from '@babel/traverse';\nimport type { Node } from '@babel/types';\nimport { ExcecoesMensagens } from '@core/messages/core/excecoes-messages.js';\n\nimport type { ContextoExecucao, Ocorrencia } from '@';\n\n/**\n * Resultado que uma técnica pode retornar\n */\nexport type TecnicaAplicarResultado = Ocorrencia | Ocorrencia[] | null | undefined;\n\n/**\n * Interface base para técnicas - versão unificada e compatível\n */\nexport interface Tecnica {\n  nome?: string;\n  global?: boolean;\n  test?: (relPath: string) => boolean;\n  aplicar: (src: string, relPath: string, ast: NodePath<Node> | null, fullCaminho?: string, contexto?: ContextoExecucao) => TecnicaAplicarResultado | Promise<TecnicaAplicarResultado>;\n}\n\n/**\n * Interface para analistas - superset de Técnica\n */\nexport interface Analista extends Tecnica {\n  nome: string; // obrigatório para identificação\n  categoria?: string; // ex: 'complexidade', 'estrutura'\n  descricao?: string; // breve resumo exibido em listagens\n  limites?: Record<string, number | boolean>; // ex: { maxLinhas: 30, ignoresTestes: true }\n  sempreAtivo?: boolean; // ignora filtros\n}\n\n/**\n * Fábrica para criar analista com validação mínima\n */\nexport function criarAnalista<A extends Analista>(def: A): A {\n  if (!def || typeof def !== 'object') throw new Error(ExcecoesMensagens.definicaoAnalistaInvalida);\n  if (!def.nome || /\\s/.test(def.nome) === false === false) {\n    // nome pode ter hifens, apenas exige não vazio\n  }\n  if (typeof def.aplicar !== 'function') throw new Error(ExcecoesMensagens.analistaSemFuncaoAplicar(def.nome));\n  return Object.freeze(def);\n}\nexport function isAnalista(item: Tecnica | Analista): item is Analista {\n  return 'nome' in item && typeof item.nome === 'string' && item.nome.length > 0;\n}\nexport function asTecnicas(items: (Tecnica | Analista)[]): import('@').Tecnica[] {\n  return items.map(raw => {\n    // Trate o item como desconhecido e faça guards em runtime para evitar exceptions\n    const item = raw as unknown as Record<string, unknown> | null;\n    const nome = item && typeof item.nome === 'string' && item.nome.length > 0 ? item.nome as string : 'analista-sem-nome';\n    const global = item && 'global' in item ? item.global as boolean | undefined : undefined;\n    const test = item && typeof item.test === 'function' ? item.test as (r: string) => boolean : undefined;\n\n    // preparar aplicar com fallback seguro (no-op retorna array vazio)\n    // Nota: capturamos erros internos para evitar promises rejeitadas sem tratamento\n    const aplicar = item && typeof item.aplicar === 'function' ? async (conteudo: string, relPath: string, ast: object | null, fullCaminho?: string, contextoGlobal?: import('@').ContextoExecucao) => {\n      const astParam = ast as import('@babel/traverse').NodePath<import('@babel/types').Node> | null;\n      const aplicarFn = item.aplicar as unknown as Tecnica['aplicar'];\n      try {\n        const r = await aplicarFn(conteudo, relPath, astParam, fullCaminho, contextoGlobal);\n        return r;\n      } catch (err) {\n        const mensagem = err instanceof Error ? err.message : String(err);\n        // Retornamos uma ocorrência descrevendo o erro do analista em vez de lançar\n        return [{\n          mensagem: `Erro ao executar analista ${nome}: ${mensagem}`,\n          nivel: 'erro',\n          relPath,\n          linha: 0,\n          tipo: 'executacao-analista'\n        } as import('@').Ocorrencia];\n      }\n    } : async () => [];\n    return {\n      nome,\n      global,\n      test,\n      aplicar\n    } as import('@').Tecnica;\n  });\n}"]}