{"version":3,"file":"registros.js","sourceRoot":"","sources":["../../src/guardian/registros.ts"],"names":[],"mappings":"AACA,OAAO,IAAI,MAAM,WAAW,CAAC;AAE7B,OAAO,EAAE,MAAM,EAAE,MAAM,wBAAwB,CAAC;AAChD,OAAO,EAAE,GAAG,EAAE,MAAM,yBAAyB,CAAC;AAC9C,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,MAAM,qCAAqC,CAAC;AAI9E,OAAO,EAAE,uBAAuB,EAAE,MAAM,WAAW,CAAC;AAEpD,MAAM,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,kBAAkB,CAAC,CAAC;AAMvE,MAAM,CAAC,KAAK,UAAU,eAAe,CACnC,WAAwB,EACxB,UAAkB,cAAc;IAEhC,MAAM,SAAS,GAA0B,EAAE,CAAC;IAE5C,KAAK,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,WAAW,EAAE,CAAC;QAC/C,IAAI,CAAC,OAAO,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE;YAAE,SAAS;QACzE,MAAM,IAAI,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAC;QAC9C,SAAS,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;IAC7C,CAAC;IAED,MAAM,EAAE,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,CAAC;IACnC,MAAM,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACpE,MAAM,YAAY,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;IACvC,GAAG,CAAC,OAAO,CAAC,yCAAyC,OAAO,EAAE,CAAC,CAAC;AAClE,CAAC;AAMD,MAAM,CAAC,KAAK,UAAU,iBAAiB,CACrC,UAAkB,cAAc;IAEhC,IAAI,CAAC;QACH,OAAO,MAAM,SAAS,CAAwB,OAAO,CAAC,CAAC;IACzD,CAAC;IAAC,MAAM,CAAC;QACP,GAAG,CAAC,KAAK,CAAC,oCAAoC,OAAO,EAAE,CAAC,CAAC;QACzD,OAAO,EAAE,CAAC;IACZ,CAAC;AACH,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT\nimport path from 'node:path';\n\nimport { config } from '@core/config/config.js';\nimport { log } from '@core/messages/index.js';\nimport { lerEstado, salvarEstado } from '@shared/persistence/persistencia.js';\n\nimport type { FileEntry, RegistroIntegridade } from '@';\n\nimport { gerarSnapshotDoConteudo } from './hash.js';\n\nconst DESTINO_PADRAO = path.join(config.STATE_DIR, 'integridade.json');\n\n/**\n * Salva os hashes dos arquivos fornecidos em um arquivo de integridade.\n */\n\nexport async function salvarRegistros(\n  fileEntries: FileEntry[],\n  destino: string = DESTINO_PADRAO,\n): Promise<void> {\n  const registros: RegistroIntegridade[] = [];\n\n  for (const { relPath, content } of fileEntries) {\n    if (!relPath || typeof content !== 'string' || !content.trim()) continue;\n    const hash = gerarSnapshotDoConteudo(content);\n    registros.push({ arquivo: relPath, hash });\n  }\n\n  const fs = await import('node:fs');\n  await fs.promises.mkdir(path.dirname(destino), { recursive: true });\n  await salvarEstado(destino, registros);\n  log.sucesso(`??? Registro de integridade salvo em: ${destino}`);\n}\n\n/**\n * Carrega os registros de integridade persistidos. Retorna lista vazia se n√£o existir.\n */\n\nexport async function carregarRegistros(\n  caminho: string = DESTINO_PADRAO,\n): Promise<RegistroIntegridade[]> {\n  try {\n    return await lerEstado<RegistroIntegridade[]>(caminho);\n  } catch {\n    log.aviso(`?? Nenhum registro encontrado em ${caminho}`);\n    return [];\n  }\n}\n"]}