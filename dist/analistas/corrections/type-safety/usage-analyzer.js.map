{"version":3,"file":"usage-analyzer.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/usage-analyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n/**\n * Analisador de uso de variáveis via AST Babel\n * Detecta padrões de uso para inferir tipos corretos\n */\n\nimport type { Node } from '@babel/types';\n\nimport type { ASTNode, PropertyUsage, TypeGuard, UsagePattern, VariableUsage } from '@';\n\n/**\n * Encontra todos os usos de uma variável no AST\n */\nexport function findVariableUsages(varNome: string, ast: Node | null): VariableUsage[] {\n  const usages: VariableUsage[] = [];\n  if (!ast || typeof ast !== 'object') {\n    return usages;\n  }\n\n  // Traversar AST recursivamente\n  traverseAST(ast, (node: ASTNode) => {\n    // Identifier usage\n    if (node.type === 'Identifier' && node.name === varNome) {\n      const usage = extractUsageFromNode(node, varNome);\n      if (usage) {\n        usages.push(usage);\n      }\n    }\n\n    // Member expression (obj.property)\n    if (node.type === 'MemberExpression' && node.object?.name === varNome) {\n      const usage = extractMemberExpressionUsage(node, varNome);\n      if (usage) {\n        usages.push(usage);\n      }\n    }\n\n    // Call expression (func())\n    if (node.type === 'CallExpression' && node.callee?.object?.name === varNome) {\n      const usage = extractCallExpressionUsage(node, varNome);\n      if (usage) {\n        usages.push(usage);\n      }\n    }\n  });\n  return usages;\n}\n\n/**\n * Analisa padrões de uso para inferir tipo\n */\nexport function analyzeUsagePatterns(usages: VariableUsage[]): UsagePattern {\n  const pattern: UsagePattern = {\n    allUsagesAreString: false,\n    allUsagesAreNumber: false,\n    allUsagesAreBoolean: false,\n    hasObjectStructure: false,\n    hasTypeGuards: false,\n    isFunction: false,\n    isArray: false\n  };\n  if (usages.length === 0) {\n    return pattern;\n  }\n\n  // Detectar métodos de string\n  const stringMethods = ['toUpperCase', 'toLowerCase', 'trim', 'substring', 'charAt', 'indexOf'];\n  const stringUsages = usages.filter(u => u.operation === 'call' && u.method && stringMethods.includes(u.method));\n\n  // Detectar métodos de number\n  const numberOperations = usages.filter(u => u.operation === 'call' && (u.method === 'toFixed' || u.method === 'toPrecision' || u.context.includes('+') || u.context.includes('-') || u.context.includes('*') || u.context.includes('/')));\n\n  // Detectar métodos de boolean\n  const booleanUsages = usages.filter(u => u.operation === 'comparison' || u.context.includes('===') || u.context.includes('!==') || u.context.includes('&&') || u.context.includes('||'));\n\n  // Detectar acesso a propriedades (objeto)\n  const propertyAccesses = usages.filter(u => u.operation === 'access' && u.property);\n\n  // Detectar chamadas de função\n  const functionCalls = usages.filter(u => u.operation === 'call' && !u.method);\n\n  // Detectar métodos de array\n  const arrayMethods = ['push', 'pop', 'map', 'filter', 'reduce', 'forEach', 'find'];\n  const arrayUsages = usages.filter(u => u.operation === 'call' && u.method && arrayMethods.includes(u.method));\n\n  // Análise final\n  pattern.allUsagesAreString = stringUsages.length > 0 && stringUsages.length === usages.length;\n  pattern.allUsagesAreNumber = numberOperations.length > 0 && numberOperations.length === usages.length;\n  pattern.allUsagesAreBoolean = booleanUsages.length > 0 && booleanUsages.length === usages.length;\n  pattern.hasObjectStructure = propertyAccesses.length > 0;\n  pattern.isFunction = functionCalls.length > 0;\n  pattern.isArray = arrayUsages.length > 0;\n\n  // Extrair propriedades de objeto\n  if (pattern.hasObjectStructure) {\n    pattern.objectProperties = extractObjectProperties(usages);\n  }\n\n  // Detectar type guards\n  const typeGuards = detectTypeGuards(usages);\n  if (typeGuards.length > 0) {\n    pattern.hasTypeGuards = true;\n    pattern.typeGuards = typeGuards;\n  }\n  return pattern;\n}\n\n/**\n * Extrai propriedades de objeto baseado em acessos\n */\nfunction extractObjectProperties(usages: VariableUsage[]): PropertyUsage[] {\n  const propertiesMap = new Map<string, PropertyUsage>();\n  for (const usage of usages) {\n    if (usage.property) {\n      const existing = propertiesMap.get(usage.property);\n      if (!existing) {\n        // Inferir tipo da propriedade baseado no método chamado\n        let inferredTipo = 'unknown';\n        let confidence = 50;\n        if (usage.method) {\n          const stringMethods = ['toUpperCase', 'toLowerCase', 'trim', 'substring'];\n          const numberMethods = ['toFixed', 'toPrecision'];\n          if (stringMethods.includes(usage.method)) {\n            inferredTipo = 'string';\n            confidence = 90;\n          } else if (numberMethods.includes(usage.method)) {\n            inferredTipo = 'number';\n            confidence = 90;\n          }\n        }\n        propertiesMap.set(usage.property, {\n          name: usage.property,\n          inferredTipo,\n          confidence,\n          isOptional: false,\n          methodsCalled: usage.method ? [usage.method] : []\n        });\n      } else {\n        // Atualizar métodos chamados\n        if (usage.method && !existing.methodsCalled?.includes(usage.method)) {\n          existing.methodsCalled = [...(existing.methodsCalled || []), usage.method];\n        }\n      }\n    }\n  }\n  return Array.from(propertiesMap.values());\n}\n\n/**\n * Detecta type guards no código\n */\nfunction detectTypeGuards(usages: VariableUsage[]): TypeGuard[] {\n  const guards: TypeGuard[] = [];\n  for (const usage of usages) {\n    const context = usage.context.toLowerCase();\n\n    // typeof guards\n    if (context.includes('typeof')) {\n      const match = context.match(/typeof\\s+\\w+\\s*===\\s*['\"](\\w+)['\"]/);\n      if (match) {\n        guards.push({\n          type: 'typeof',\n          expression: usage.context,\n          inferredTipo: match[1],\n          confidence: 95\n        });\n      }\n    }\n\n    // instanceof guards\n    if (context.includes('instanceof')) {\n      const match = context.match(/\\w+\\s+instanceof\\s+(\\w+)/);\n      if (match) {\n        guards.push({\n          type: 'instanceof',\n          expression: usage.context,\n          inferredTipo: match[1],\n          confidence: 95\n        });\n      }\n    }\n\n    // 'in' operator guards\n    if (context.includes(' in ')) {\n      const match = context.match(/['\"](\\w+)['\"]\\s+in\\s+\\w+/);\n      if (match) {\n        guards.push({\n          type: 'in',\n          expression: usage.context,\n          inferredTipo: `{ ${match[1]}: unknown }`,\n          confidence: 80\n        });\n      }\n    }\n  }\n  return guards;\n}\n\n/**\n * Traversa AST recursivamente\n */\nfunction traverseAST(node: unknown, visitor: (node: ASTNode) => void): void {\n  if (!node || typeof node !== 'object') {\n    return;\n  }\n  visitor(node as ASTNode);\n  for (const key in node as Record<string, unknown>) {\n    if (key === 'loc' || key === 'start' || key === 'end' || key === 'range') {\n      continue; // Skip location metadata\n    }\n    const child = (node as Record<string, unknown>)[key];\n    if (Array.isArray(child)) {\n      for (const item of child) {\n        traverseAST(item, visitor);\n      }\n    } else if (child && typeof child === 'object') {\n      traverseAST(child, visitor);\n    }\n  }\n}\n\n/**\n * Extrai informações de uso de um nó Identifier\n */\nfunction extractUsageFromNode(node: ASTNode, varNome: string): VariableUsage | null {\n  return {\n    name: varNome,\n    nodeType: node.type || 'unknown',\n    line: node.loc?.start?.line || 0,\n    column: node.loc?.start?.column || 0,\n    context: extractNodeContext(node),\n    operation: 'access'\n  };\n}\n\n/**\n * Extrai informações de MemberExpression\n */\nfunction extractMemberExpressionUsage(node: ASTNode, varNome: string): VariableUsage | null {\n  const property = node.property?.name || (node.property as ASTNode)?.value;\n  return {\n    name: varNome,\n    nodeType: 'MemberExpression',\n    line: node.loc?.start?.line || 0,\n    column: node.loc?.start?.column || 0,\n    context: extractNodeContext(node),\n    operation: 'access',\n    property: property ? String(property) : undefined\n  };\n}\n\n/**\n * Extrai informações de CallExpression\n */\nfunction extractCallExpressionUsage(node: ASTNode, varNome: string): VariableUsage | null {\n  const method = node.callee?.property?.name;\n  return {\n    name: varNome,\n    nodeType: 'CallExpression',\n    line: node.loc?.start?.line || 0,\n    column: node.loc?.start?.column || 0,\n    context: extractNodeContext(node),\n    operation: 'call',\n    method: method ? String(method) : undefined\n  };\n}\n\n/**\n * Extrai contexto ao redor de um nó (para análise)\n */\nfunction extractNodeContext(node: ASTNode): string {\n  // Simplificado - em produção, usar gerador de código do Babel\n  if (node.type === 'Identifier') {\n    return String(node.name || '');\n  }\n  if (node.type === 'MemberExpression') {\n    const obj = node.object?.name || extractNodeContext(node.object as ASTNode);\n    const prop = node.property?.name || (node.property as ASTNode)?.value;\n    return `${obj}.${prop}`;\n  }\n  if (node.type === 'CallExpression') {\n    const callee = extractNodeContext(node.callee as ASTNode);\n    return `${callee}()`;\n  }\n  return String(node.type || '');\n}"]}