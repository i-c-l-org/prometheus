{"version":3,"file":"type-creator.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/type-creator.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT-0\n/**\n * Sistema de criação de arquivos de tipos\n * Cria tipos no diretório configurado (conventions.typesDirectory) com organização correta\n */\n\nimport { promises as fs } from 'node:fs';\nimport path from 'node:path';\n\nimport { buildTypesFsPath } from '@core/config/conventions.js';\n\nimport type { ExistingType, TypeAnalysis } from '@';\n\nimport { toKebabCase } from './context-analyzer.js';\n\n/**\n * Cria definição de tipo no diretório configurado (conventions.typesDirectory)\n */\nexport async function createTypeDefinition(analysis: TypeAnalysis, sourceFilePath: string): Promise<string> {\n  const domain = extractDomain(sourceFilePath);\n  const fileNome = toKebabCase(analysis.typeName);\n  const typeCaminho = buildTypesFsPath(path.posix.join(domain, `${fileNome}.ts`));\n\n  // Verificar se tipo já existe\n  const existing = await findExistingType(analysis.typeName);\n  if (existing) {\n    // Retornar caminho do alias existente\n    return `@types/types`; // Usar export centralizado\n  }\n\n  // Criar diretório se não existir\n  const dir = path.dirname(typeCaminho);\n  await fs.mkdir(dir, {\n    recursive: true\n  });\n\n  // Gerar conteúdo do arquivo\n  const content = generateTypeFileContent(analysis, sourceFilePath);\n\n  // Escrever arquivo\n  await fs.writeFile(typeCaminho, content, 'utf-8');\n\n  // Adicionar export ao index.ts do domínio\n  await addExportToIndex(domain, fileNome);\n\n  // Retornar alias de import\n  return `@types/types`;\n}\n\n/**\n * Busca tipo existente no diretório configurado (conventions.typesDirectory)\n */\nexport async function findExistingType(typeName: string): Promise<ExistingType | null> {\n  try {\n    const tiposDir = buildTypesFsPath('');\n    const types = await scanTypesDirectory(tiposDir);\n    for (const type of types) {\n      if (type.name === typeName) {\n        return type;\n      }\n    }\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Verifica se dois tipos são iguais\n */\nexport function isSameType(type1: ExistingType, type2: string): boolean {\n  // Simplificado - em produção, usar parser para comparação estrutural\n  const normalize = (str: string) => str.replace(/\\s+/g, ' ').trim();\n  return normalize(type1.definition) === normalize(type2);\n}\n\n/**\n * Gera conteúdo do arquivo de tipo\n */\nfunction generateTypeFileContent(analysis: TypeAnalysis, sourceFilePath: string): string {\n  const date = new Date().toISOString();\n  return `// SPDX-License-Identifier: MIT-0\n/**\n * Tipo gerado automaticamente\n * Origem: ${sourceFilePath}\n * Confiança: ${analysis.confidence}%\n * Data: ${date}\n *\n * @generated by prometheus fix-any-to-proper-type\n */\n\n${analysis.typeDefinition}\n`;\n}\n\n/**\n * Adiciona export ao index.ts do domínio\n */\nasync function addExportToIndex(domain: string, fileNome: string): Promise<void> {\n  const indexCaminho = buildTypesFsPath(path.posix.join(domain, 'index.ts'));\n  try {\n    // Verificar se arquivo index.ts existe\n    await fs.access(indexCaminho);\n\n    // Ler conteúdo atual\n    const content = await fs.readFile(indexCaminho, 'utf-8');\n\n    // Verificar se export já existe\n    const exportStatement = `export * from './${fileNome}.js';`;\n    if (content.includes(exportStatement)) {\n      return; // Já existe\n    }\n\n    // Adicionar export\n    await fs.appendFile(indexCaminho, `${exportStatement}\\n`, 'utf-8');\n  } catch {\n    // Criar index.ts se não existir\n    const header = `// SPDX-License-Identifier: MIT-0\n/**\n * Exports do domínio ${domain}\n */\n\n`;\n    const exportStatement = `export * from './${fileNome}.js';\\n`;\n    await fs.writeFile(indexCaminho, header + exportStatement, 'utf-8');\n  }\n}\n\n/**\n * Extrai domínio do caminho do arquivo\n */\nfunction extractDomain(fileCaminho: string): string {\n  const match = fileCaminho.match(/src[\\\\/]([\\w-]+)[\\\\/]/);\n  return match ? match[1] : 'shared';\n}\n\n/**\n * Escaneia diretório de tipos\n */\nasync function scanTypesDirectory(dir: string): Promise<ExistingType[]> {\n  const types: ExistingType[] = [];\n  try {\n    const entries = await fs.readdir(dir, {\n      withFileTypes: true\n    });\n    for (const entry of entries) {\n      const fullCaminho = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        // Recursivo\n        const subTipos = await scanTypesDirectory(fullCaminho);\n        types.push(...subTipos);\n      } else if (entry.name.endsWith('.ts') && entry.name !== 'index.ts') {\n        // Ler arquivo e extrair tipos\n        const content = await fs.readFile(fullCaminho, 'utf-8');\n        const extractedTipos = extractTypesFromFile(content, fullCaminho);\n        types.push(...extractedTipos);\n      }\n    }\n  } catch {\n    // Ignorar erros\n  }\n  return types;\n}\n\n/**\n * Extrai tipos de um arquivo\n */\nfunction extractTypesFromFile(content: string, fileCaminho: string): ExistingType[] {\n  const types: ExistingType[] = [];\n\n  // Regex simples para encontrar interfaces e types exportados\n  const interfaceRegex = /export\\s+interface\\s+(\\w+)\\s*{([^}]*)}/g;\n  const typeRegex = /export\\s+type\\s+(\\w+)\\s*=\\s*([^;]+);/g;\n  let match;\n\n  // Interfaces\n  while ((match = interfaceRegex.exec(content)) !== null) {\n    types.push({\n      name: match[1],\n      path: fileCaminho,\n      definition: match[0],\n      isExported: true,\n      domain: extractDomain(fileCaminho)\n    });\n  }\n\n  // Types\n  while ((match = typeRegex.exec(content)) !== null) {\n    types.push({\n      name: match[1],\n      path: fileCaminho,\n      definition: match[0],\n      isExported: true,\n      domain: extractDomain(fileCaminho)\n    });\n  }\n  return types;\n}"]}