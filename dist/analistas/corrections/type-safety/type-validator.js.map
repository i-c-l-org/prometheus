{"version":3,"file":"type-validator.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/type-validator.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT-0\n/**\n * Validação de tipos criados/modificados\n * Verifica compatibilidade e compilação TypeScript\n */\n\nimport type { TypeAnalysis, TypeReplacementValidation } from '@';\n\nimport { findExistingType, isSameType } from './type-creator.js';\n\n/**\n * Valida substituição de tipo (any/unknown → specific)\n */\nexport async function validateTypeReplacement(originalCode: string, fixedCodigo: string, typeAnalise: TypeAnalysis): Promise<TypeReplacementValidation> {\n  const result: TypeReplacementValidation = {\n    isCompatible: true,\n    expectedType: typeAnalise.inferredTipo,\n    errors: [],\n    warnings: []\n  };\n\n  // 1. Verificar se tipo criado já existe com definição diferente\n  if (typeAnalise.createdNewType) {\n    const existingTipo = await findExistingType(typeAnalise.typeName);\n    if (existingTipo && !isSameType(existingTipo, typeAnalise.typeDefinition)) {\n      result.warnings.push(`Tipo ${typeAnalise.typeName} já existe com definição diferente. ` + `Verifique conflito em ${existingTipo.path}`);\n    }\n  }\n\n  // 2. Verificar se tipo inferido é compatível com uso\n  const usageValidation = validateTypeUsageCompatibility(fixedCodigo, typeAnalise);\n  if (!usageValidation.isCompatible) {\n    result.errors.push(`Tipo inferido ${typeAnalise.inferredTipo} incompatível com uso detectado. ` + `Esperado: ${usageValidation.expectedType}`);\n    result.isCompatible = false;\n  }\n\n  // 3. Verificar se import foi adicionado corretamente\n  if (typeAnalise.requiresImport) {\n    const hasCorrectImport = fixedCodigo.includes(`import type { ${typeAnalise.typeName} }`) || fixedCodigo.includes(`import { type ${typeAnalise.typeName} }`);\n    if (!hasCorrectImport) {\n      result.errors.push(`Import de tipo ${typeAnalise.typeName} não encontrado`);\n      result.isCompatible = false;\n    }\n  }\n\n  // 4. Verificar confiança mínima\n  if (typeAnalise.confidence < 60) {\n    result.warnings.push(`Confiança muito baixa (${typeAnalise.confidence}%). Considere revisão manual.`);\n  }\n\n  // 5. Validar sintaxe básica do código modificado\n  const syntaxValidation = validateBasicSyntax(fixedCodigo);\n  if (!syntaxValidation.isValid) {\n    result.errors.push(...syntaxValidation.errors);\n    result.isCompatible = false;\n  }\n  return result;\n}\n\n/**\n * Valida compatibilidade do tipo inferido com uso real\n */\nfunction validateTypeUsageCompatibility(code: string, typeAnalise: TypeAnalysis): {\n  isCompatible: boolean;\n  expectedType: string;\n} {\n  // Simplificado - em produção, usar TypeScript compiler API\n  // para verificação completa\n\n  // Por enquanto, considerar compatível se confiança >= 70%\n  const isCompatible = typeAnalise.confidence >= 70;\n  return {\n    isCompatible,\n    expectedType: typeAnalise.inferredTipo\n  };\n}\n\n/**\n * Valida sintaxe básica do código\n */\nfunction validateBasicSyntax(code: string): {\n  isValid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Verificar balanceamento de chaves\n  const braceContagem = (code.match(/{/g) || []).length - (code.match(/}/g) || []).length;\n  if (braceContagem !== 0) {\n    errors.push(`Chaves desbalanceadas: diferença de ${Math.abs(braceContagem)}`);\n  }\n\n  // Verificar balanceamento de parênteses\n  const parenContagem = (code.match(/\\(/g) || []).length - (code.match(/\\)/g) || []).length;\n  if (parenContagem !== 0) {\n    errors.push(`Parênteses desbalanceados: diferença de ${Math.abs(parenContagem)}`);\n  }\n\n  // Verificar balanceamento de colchetes\n  const bracketContagem = (code.match(/\\[/g) || []).length - (code.match(/\\]/g) || []).length;\n  if (bracketContagem !== 0) {\n    errors.push(`Colchetes desbalanceados: diferença de ${Math.abs(bracketContagem)}`);\n  }\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Simula compilação TypeScript (simplificado)\n * Em produção, usar TypeScript compiler API\n */\nexport function runTypeScriptCompiler(code: string): {\n  hasErrors: boolean;\n  errors: string[];\n} {\n  // Simplificado - validações básicas\n  const errors: string[] = [];\n\n  // Verificar imports malformados\n  const importLines = code.split('\\n').filter(line => line.trim().startsWith('import'));\n  for (const line of importLines) {\n    if (!line.includes('from') && !line.includes('=')) {\n      errors.push(`Import malformado: ${line.trim()}`);\n    }\n  }\n\n  // Verificar sintaxe de interface\n  const interfaceRegex = /interface\\s+\\w+\\s*{[^}]*}/g;\n  const interfaces = code.match(interfaceRegex) || [];\n  for (const iface of interfaces) {\n    // Verificar propriedades\n    const properties = iface.match(/\\w+\\s*\\??\\s*:\\s*[\\w\\[\\]<>|&\\s]+;/g);\n    if (!properties) {\n      errors.push(`Interface malformada: ${iface.substring(0, 50)}...`);\n    }\n  }\n  return {\n    hasErrors: errors.length > 0,\n    errors\n  };\n}"]}