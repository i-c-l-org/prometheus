{"version":3,"file":"type-analyzer.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/type-analyzer.ts"],"names":[],"mappings":"AAOA,OAAO,EAAE,wBAAwB,EAAE,MAAM,6BAA6B,CAAC;AACvE,OAAO,EAAE,wBAAwB,EAAE,MAAM,yBAAyB,CAAC;AAInE,OAAO,EAAE,mBAAmB,EAAE,qBAAqB,EAAE,gBAAgB,EAAE,oBAAoB,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAC;AAC7I,OAAO,EAAE,kBAAkB,EAAE,MAAM,qBAAqB,CAAC;AACzD,OAAO,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,MAAM,qBAAqB,CAAC;AAK/E,MAAM,CAAC,KAAK,UAAU,gBAAgB,CAAC,KAAuB,EAAE,QAAgB,EAAE,WAAmB,EAAE,GAAgB;IAErH,MAAM,OAAO,GAAyB;QACpC,WAAW;QACX,MAAM,EAAE,qBAAqB,CAAC,WAAW,CAAC;QAC1C,YAAY,EAAE,gBAAgB,CAAC,WAAW,CAAC;QAC3C,gBAAgB,EAAE,gBAAgB,CAAC,WAAW,CAAC;QAC/C,QAAQ,EAAE,oBAAoB,CAAC,WAAW,CAAC;QAC3C,GAAG;QACH,IAAI,EAAE,QAAQ;KACf,CAAC;IAGF,MAAM,OAAO,GAAG,mBAAmB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACrD,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,OAAO;YACL,UAAU,EAAE,CAAC;YACb,YAAY,EAAE,SAAS;YACvB,YAAY,EAAE,KAAK;YACnB,QAAQ,EAAE,EAAE;YACZ,cAAc,EAAE,EAAE;YAClB,aAAa,EAAE,EAAE;YACjB,UAAU,EAAE,wBAAwB,CAAC,KAAK,CAAC,WAAW;SACvD,CAAC;IACJ,CAAC;IAGD,MAAM,MAAM,GAAG,kBAAkB,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IAChD,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,OAAO;YACL,UAAU,EAAE,EAAE;YACd,YAAY,EAAE,SAAS;YACvB,YAAY,EAAE,KAAK;YACnB,QAAQ,EAAE,EAAE;YACZ,cAAc,EAAE,EAAE;YAClB,aAAa,EAAE,EAAE;YACjB,UAAU,EAAE,wBAAwB,CAAC,KAAK,CAAC,gBAAgB;SAC5D,CAAC;IACJ,CAAC;IAGD,MAAM,QAAQ,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAG9C,MAAM,WAAW,GAAG,kBAAkB,CAAC,OAAO,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;IAGvE,IAAI,WAAW,CAAC,aAAa,EAAE,CAAC;QAC9B,WAAW,CAAC,aAAa,GAAG,GAAG,OAAO,CAAC,MAAM,IAAI,WAAW,CAAC,aAAa,EAAE,CAAC;IAC/E,CAAC;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AAKD,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,KAAuB,EAAE,QAAgB,EAAE,WAAmB,EAAE,GAAgB;IAExH,MAAM,QAAQ,GAAG,MAAM,gBAAgB,CAAC,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;IAG3E,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,UAAU,GAAG,EAAE,CAAC,CAAC;IAG5D,IAAI,QAAQ,CAAC,UAAU,GAAG,EAAE,EAAE,CAAC;QAC7B,QAAQ,CAAC,UAAU,GAAG,2CAA2C,GAAG,6DAA6D,wBAAwB,EAAE,EAAE,CAAC;IAChK,CAAC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT\n/**\n * Analisador principal de tipos\n * Integra context-analyzer, usage-analyzer e type-inference\n */\n\nimport type { Node } from '@babel/types';\nimport { getTypesDirectoryDisplay } from '@core/config/conventions.js';\nimport { MENSAGENS_CORRECAO_TIPOS } from '@core/messages/index.js';\n\nimport type { TypeAnalysis, TypeInferenceContext } from '@';\n\nimport { extractVariableName, getDomainFromFilePath, isDefinitionFile, isLegacyOrVendorFile, isTypeScriptFile } from './context-analyzer.js';\nimport { inferTypeFromUsage } from './type-inference.js';\nimport { analyzeUsagePatterns, findVariableUsages } from './usage-analyzer.js';\n\n/**\n * Analisa uso de any/unknown e infere tipo correto\n */\nexport async function analyzeTypeUsage(match: RegExpMatchArray, fullCode: string, fileCaminho: string, ast: Node | null): Promise<TypeAnalysis> {\n  // 1. Criar contexto de inferência\n  const context: TypeInferenceContext = {\n    fileCaminho,\n    domain: getDomainFromFilePath(fileCaminho),\n    isTypeScript: isTypeScriptFile(fileCaminho),\n    isDefinitionFile: isDefinitionFile(fileCaminho),\n    isLegacy: isLegacyOrVendorFile(fileCaminho),\n    ast,\n    code: fullCode\n  };\n\n  // 2. Extrair nome da variável\n  const varNome = extractVariableName(match, fullCode);\n  if (!varNome) {\n    return {\n      confidence: 0,\n      inferredTipo: 'unknown',\n      isSimpleType: false,\n      typeName: '',\n      typeDefinition: '',\n      suggestedPath: '',\n      suggestion: MENSAGENS_CORRECAO_TIPOS.erros.extrairNome\n    };\n  }\n\n  // 3. Encontrar usos da variável no AST\n  const usages = findVariableUsages(varNome, ast);\n  if (usages.length === 0) {\n    return {\n      confidence: 20,\n      inferredTipo: 'unknown',\n      isSimpleType: false,\n      typeName: '',\n      typeDefinition: '',\n      suggestedPath: '',\n      suggestion: MENSAGENS_CORRECAO_TIPOS.erros.variavelNaoUsada\n    };\n  }\n\n  // 4. Analisar padrões de uso\n  const patterns = analyzeUsagePatterns(usages);\n\n  // 5. Inferir tipo baseado nos padrões\n  const typeAnalise = inferTypeFromUsage(varNome, patterns, fileCaminho);\n\n  // 6. Ajustar suggestedPath com domínio correto\n  if (typeAnalise.suggestedPath) {\n    typeAnalise.suggestedPath = `${context.domain}/${typeAnalise.suggestedPath}`;\n  }\n  return typeAnalise;\n}\n\n/**\n * Analisa uso de unknown com foco em type guards\n */\nexport async function analyzeUnknownUsage(match: RegExpMatchArray, fullCode: string, fileCaminho: string, ast: Node | null): Promise<TypeAnalysis> {\n  // Mesma lógica de analyzeTypeUsage, mas mais conservador\n  const analysis = await analyzeTypeUsage(match, fullCode, fileCaminho, ast);\n\n  // Penalizar confiança em 10% para unknown (mais conservador)\n  analysis.confidence = Math.max(0, analysis.confidence - 10);\n\n  // Se confiança ainda é baixa, sugerir manter unknown\n  if (analysis.confidence < 70) {\n    analysis.suggestion = 'Confiança baixa para substituir unknown. ' + `Considere adicionar type guards ou criar tipo dedicado em ${getTypesDirectoryDisplay()}`;\n  }\n  return analysis;\n}"]}