{"version":3,"file":"analista-todo-comments.js","sourceRoot":"","sources":["../../../src/analistas/js-ts/analista-todo-comments.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT-0\nimport type { NodePath } from '@babel/traverse';\nimport type { Comment } from '@babel/types';\nimport { TodoComentariosMensagens } from '@core/messages/analistas/analista-todo-comments-messages.js';\nimport { detectarContextoProjeto } from '@shared/contexto-projeto.js';\n\nimport type { Analista, TecnicaAplicarResultado } from '@';\nimport { criarOcorrencia } from '@';\n\n// Evita warning de unused import - função usada em runtime\nvoid detectarContextoProjeto;\n\n// Analista simples para detectar TODO em comentários (//, /* */), ignorando testes/specs\nexport const analistaTodoComentarios: Analista = {\n  nome: 'todo-comments',\n  categoria: 'qualidade',\n  descricao: 'Detecta comentários TODO deixados no código (apenas em comentários).',\n  // Per-file (não global): executa por arquivo\n  global: false,\n  test(relPath) {\n    // Usa o sistema de contexto inteligente\n    const contextoArquivo = detectarContextoProjeto({\n      arquivo: relPath,\n      conteudo: '',\n      relPath\n    });\n\n    // Ignora testes, configs e infraestrutura\n    if (contextoArquivo.isTest || contextoArquivo.isConfiguracao || contextoArquivo.frameworks.includes('types')) {\n      return false;\n    }\n\n    // Evita auto-detecção neste próprio arquivo\n    if (/analistas[\\\\\\/]analista-todo-comments\\.(ts|js)$/i.test(relPath)) return false;\n    return /\\.(ts|js|tsx|jsx)$/i.test(relPath);\n  },\n  aplicar(src, relPath, ast?: NodePath | null): TecnicaAplicarResultado {\n    // Aplicar contexto inteligente\n    const contextoArquivo = detectarContextoProjeto({\n      arquivo: relPath,\n      conteudo: src,\n      relPath\n    });\n\n    // Nível baseado no contexto\n    const nivelTodo = contextoArquivo.isLibrary ? 'aviso' : 'info';\n    const RE_FAZER_INICIO = /^TODO\\b/i;\n    const RE_FAZER_ANY = /\\bTODO\\b\\s*[:\\-(\\[]/i;\n\n    // Detecta se o TODO é parte de um template JSDoc gerado automaticamente\n    const isJSDocTemplate = (linha: string, _linhaAnterior?: string): boolean => {\n      // Padrões típicos de JSDoc templates automáticos\n      const templatePadroes = [/\\*\\s*TODO:\\s*Adicionar descrição da função\\s*$/i, /\\*\\s*@param\\s+\\{[^}]*\\}\\s+\\w+\\s*-\\s*TODO:\\s*Descrever parâmetro\\s*$/i, /\\*\\s*@returns\\s+\\{[^}]*\\}\\s*TODO:\\s*Descrever retorno\\s*$/i];\n      return templatePadroes.some(pattern => pattern.test(linha));\n    };\n    const isTodoComment = (texto: string, linhaCompleta?: string, linhaAnterior?: string): boolean => {\n      const t = String(texto ?? '').trim();\n      const isTodo = RE_FAZER_INICIO.test(t) || RE_FAZER_ANY.test(t);\n\n      // Se é TODO, verifica se é template JSDoc\n      if (isTodo && linhaCompleta && isJSDocTemplate(linhaCompleta, linhaAnterior)) {\n        return false; // Ignora TODOs em templates JSDoc\n      }\n      return isTodo;\n    };\n\n    // Localiza marcadores de comentário ignorando ocorrências dentro de strings (', \", `)\n    const localizarMarcadores = (linha: string): {\n      lineIdx: number;\n      blockIdx: number;\n    } => {\n      let inS = false;\n      let inD = false;\n      let inB = false;\n      let prev = '';\n      for (let i = 0; i < linha.length; i++) {\n        const ch = linha[i];\n        const pair = prev + ch;\n        // alterna estados de string considerando escapes simples\n        if (!inD && !inB && ch === \"'\" && prev !== '\\\\') inS = !inS;else if (!inS && !inB && ch === '\"' && prev !== '\\\\') inD = !inD;else if (!inS && !inD && ch === '`' && prev !== '\\\\') inB = !inB;\n\n        // apenas quando não dentro de strings detectar comentários\n        if (!inS && !inD && !inB) {\n          if (pair === '//') {\n            return {\n              lineIdx: i - 1,\n              blockIdx: -1\n            };\n          }\n          if (pair === '/*') {\n            return {\n              lineIdx: -1,\n              blockIdx: i - 1\n            };\n          }\n        }\n        prev = ch;\n      }\n      return {\n        lineIdx: -1,\n        blockIdx: -1\n      };\n    };\n    if (!src || typeof src !== 'string') return null;\n    // Evita auto-detecção neste próprio arquivo (defesa dupla)\n    if (/analistas[\\\\\\/]analista-todo-comments\\.(ts|js)$/i.test(relPath)) return null;\n\n    // Caminho preferencial: usar comentários da AST quando disponível\n    if (ast && ast.node) {\n      const maybeWithComentarios = ast.node as unknown as {\n        comments?: Comment[];\n      };\n      if (Array.isArray(maybeWithComentarios.comments)) {\n        const comments = maybeWithComentarios.comments;\n        const ocorrencias = comments.filter(c => {\n          const texto = String(c.value ?? '').trim();\n          // Para comentários AST, não temos acesso fácil ao contexto de linha\n          // Vamos usar uma heurística mais simples aqui\n          return isTodoComment(texto);\n        }).map(c => criarOcorrencia({\n          tipo: 'TODO-pendente',\n          mensagem: TodoComentariosMensagens.todoFound,\n          nivel: nivelTodo,\n          relPath,\n          linha: c.loc?.start.line,\n          origem: 'todo-comments'\n        }));\n        return ocorrencias.length ? ocorrencias : null;\n      }\n    }\n\n    // Heurística: considera TODO apenas quando presente em comentários\n    const linhas = src.split(/\\r?\\n/);\n    const ocorrenciasLinhas: number[] = [];\n    let emBloco = false;\n    for (let i = 0; i < linhas.length; i++) {\n      const linha = linhas[i];\n      let analisada = false;\n\n      // Verifica comentários de bloco (/* ... */)\n      if (emBloco) {\n        analisada = true;\n        const linhaAnterior = i > 0 ? linhas[i - 1] : undefined;\n        if (isTodoComment(linha, linha, linhaAnterior)) {\n          ocorrenciasLinhas.push(i + 1);\n        }\n        if (linha.includes('*/')) {\n          emBloco = false;\n        }\n      }\n      if (!analisada) {\n        // Procura início de bloco e comentário de linha ignorando strings\n        const {\n          blockIdx: idxBlockStart,\n          lineIdx: idxLine\n        } = localizarMarcadores(linha);\n\n        // Caso comentário de linha\n        if (idxLine >= 0 && (idxBlockStart === -1 || idxLine < idxBlockStart)) {\n          const trechoComentario = linha.slice(idxLine + 2);\n          const linhaAnterior = i > 0 ? linhas[i - 1] : undefined;\n          if (isTodoComment(trechoComentario, linha, linhaAnterior)) {\n            ocorrenciasLinhas.push(i + 1);\n          }\n          continue;\n        }\n\n        // Caso bloco começando nesta linha\n        if (idxBlockStart >= 0) {\n          const trechoAposInicio = linha.slice(idxBlockStart + 2);\n          const linhaAnterior = i > 0 ? linhas[i - 1] : undefined;\n          if (isTodoComment(trechoAposInicio, linha, linhaAnterior)) {\n            ocorrenciasLinhas.push(i + 1);\n          }\n          if (!linha.includes('*/')) {\n            emBloco = true;\n          }\n          continue;\n        }\n      }\n    }\n    if (ocorrenciasLinhas.length === 0) return null;\n    return ocorrenciasLinhas.map(linha => criarOcorrencia({\n      tipo: 'TODO-pendente',\n      mensagem: TodoComentariosMensagens.todoFound,\n      nivel: nivelTodo,\n      relPath,\n      linha,\n      origem: 'todo-comments'\n    }));\n  }\n};\nexport default analistaTodoComentarios;"]}