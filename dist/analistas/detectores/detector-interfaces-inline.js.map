{"version":3,"file":"detector-interfaces-inline.js","sourceRoot":"","sources":["../../../src/analistas/detectores/detector-interfaces-inline.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT-0\n// @prometheus-disable PROBLEMA_PERFORMANCE\n// Justificativa: detector que analisa código-fonte - loops são esperados\n/**\n * Detector de Interfaces Inline\n * Identifica definições de interfaces e tipos complexos inline que deveriam estar em arquivos de tipos\n *\n * Estratégia:\n * - Detecta interfaces inline em funções, classes e variáveis\n * - Identifica tipos complexos que deveriam ser extraídos\n * - Sugere movimentação para o diretório de tipos configurado (conventions.typesDirectory)\n * - Analisa reutilização e complexidade para priorizar extrações\n */\n\nimport type { NodePath } from '@babel/traverse';\nimport type { Node } from '@babel/types';\nimport { getTypesDirectoryDisplay, isInsideTypesDirectory } from '@core/config/conventions.js';\nimport { DetectorInterfacesInlineMensagens } from '@core/messages/analistas/detector-interfaces-inline-messages.js';\n\nimport type { Analista, InterfaceInlineDetection, Ocorrencia } from '@';\n\n/** Ocorrência de tipo inline extraída do código (evita tipo duplicado em vários pontos). */\ninterface InlineTypeOccurrence {\n  tipo: string;\n  estrutura: string;\n  linha: number;\n  contexto: string;\n}\n\nconst ANALISTA: Analista = {\n  nome: 'detector-interfaces-inline',\n  categoria: 'code-organization',\n  descricao: 'Detecta interfaces e tipos complexos inline que deveriam estar em arquivos de tipos',\n  test: (relPath: string) => {\n    // Não analisar arquivos que já estão na pasta de tipos\n    if (isInsideTypesDirectory(relPath)) {\n      return false;\n    }\n\n    // Não analisar arquivos de definição de tipos do TypeScript\n    if (relPath.endsWith('.d.ts')) {\n      return false;\n    }\n\n    // Não analisar arquivos deprecados\n    if (relPath.includes('/.deprecados/') || relPath.includes('\\\\.deprecados\\\\')) {\n      return false;\n    }\n\n    // Não analisar node_modules\n    if (relPath.includes('/node_modules/') || relPath.includes('\\\\node_modules\\\\')) {\n      return false;\n    }\n    return relPath.endsWith('.ts') || relPath.endsWith('.tsx');\n  },\n  aplicar: async (srcParam: string, relPath: string, _ast: NodePath<Node> | null, _fullPath?: string): Promise<Ocorrencia[]> => {\n    const ocorrencias: Ocorrencia[] = [];\n\n    // Normalização de line endings\n    const src = srcParam.replace(/\\r\\n/g, '\\n');\n    const _linhas = src.split('\\n');\n\n    // 1. Detectar interfaces inline em funções EXPORTADAS\n    // Funções locais podem ter tipos inline simples sem problema\n    const interfaceInlinePadrao = /export\\s+function\\s+\\w+\\s*\\([^)]*\\):\\s*{[^}]+}/g;\n    let match: RegExpMatchArray | null;\n    while ((match = interfaceInlinePadrao.exec(src)) !== null) {\n      const position = match.index || 0;\n      const linha = src.substring(0, position).split('\\n').length;\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n      const detection = analyzeInlineInterface(match[0], linha, 'function-return');\n      // Aumentar threshold para 5 propriedades em tipos de retorno\n      if (detection && detection.complexidade >= 5) {\n        ocorrencias.push(createOcorrencia(detection, relPath));\n      }\n    }\n\n    // 2. Detectar tipos literais complexos em parâmetros\n    // Apenas reportar parâmetros realmente complexos (5+ propriedades)\n    const complexParamPadrao = /\\w+\\s*:\\s*{\\s*[^}]+;\\s*[^}]+;\\s*[^}]+}/g;\n    while ((match = complexParamPadrao.exec(src)) !== null) {\n      const position = match.index || 0;\n      const linha = src.substring(0, position).split('\\n').length;\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n      const detection = analyzeInlineInterface(match[0], linha, 'parameter');\n      // Aumentar threshold para 5 propriedades em parâmetros\n      if (detection && detection.complexidade >= 5) {\n        ocorrencias.push(createOcorrencia(detection, relPath));\n      }\n    }\n\n    // 3. Detectar type aliases inline com uniões complexas\n    // Buscar declarações de type e depois extrair o conteúdo completo\n    const typeInicioPadrao = /type\\s+(\\w+)\\s*=/g;\n    let startMatch: RegExpMatchArray | null;\n    while ((startMatch = typeInicioPadrao.exec(src)) !== null) {\n      const position = startMatch.index || 0;\n      const nomeTipo = startMatch[1];\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n\n      // Extrair o tipo completo (até o próximo ponto-e-vírgula no nível raiz)\n      const afterEquals = src.substring(position + startMatch[0].length);\n      const tipoCompleto = extractTypeDefinition(afterEquals);\n      if (!tipoCompleto) {\n        continue;\n      }\n      const linha = src.substring(0, position).split('\\n').length;\n      const complexidade = calculateComplexidade(tipoCompleto);\n\n      // Aumentar threshold para 5 propriedades em type aliases\n      if (complexidade >= 5) {\n        const detection: InterfaceInlineDetection = {\n          tipo: 'type-alias',\n          nome: nomeTipo,\n          linha,\n          complexidade,\n          contexto: tipoCompleto.substring(0, 100),\n          sugestao: DetectorInterfacesInlineMensagens.moverTipoParaTipos(nomeTipo)\n        };\n        ocorrencias.push(createOcorrencia(detection, relPath));\n      }\n    }\n\n    // 4. Detectar interfaces exportadas inline (PRIORIDADE MÁXIMA)\n    // Pattern para capturar 'export interface Nome' de forma precisa\n    const exportInterfacePadrao = /export\\s+interface\\s+(\\w+)\\s*(<[^>]*>)?\\s*\\{/g;\n    while ((match = exportInterfacePadrao.exec(src)) !== null) {\n      const position = match.index || 0;\n      const linha = src.substring(0, position).split('\\n').length;\n      const nomeInterface = match[1];\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n\n      // Interfaces exportadas SEMPRE devem estar em tipos/\n      const detection: InterfaceInlineDetection = {\n        tipo: 'interface',\n        nome: nomeInterface,\n        linha,\n        complexidade: 0,\n        // Não importa - exportada sempre reporta\n        contexto: `export interface ${nomeInterface}`,\n        sugestao: DetectorInterfacesInlineMensagens.interfaceExportadaParaTipos(nomeInterface)\n      };\n      ocorrencias.push(createOcorrencia(detection, relPath));\n    }\n\n    // 5. Detectar interfaces declaradas inline (não exportadas, mas complexas)\n    // Pattern melhorado para capturar interfaces multi-linha\n    const interfaceDeclarationPadrao = /(?<!export\\s+)interface\\s+(\\w+)\\s*\\{[\\s\\S]+?\\}/g;\n    while ((match = interfaceDeclarationPadrao.exec(src)) !== null) {\n      const position = match.index || 0;\n      const linha = src.substring(0, position).split('\\n').length;\n      const nomeInterface = match[1];\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n\n      // Verificar se não foi já detectada como exportada\n      const jaDetetada = ocorrencias.some(o => o.linha === linha && o.mensagem?.includes(nomeInterface));\n      if (jaDetetada) {\n        continue;\n      }\n\n      // Verificar se interface é local (começa com minúscula)\n      const isLocal = /^[a-z]/.test(nomeInterface);\n\n      // Só reportar se for complexa e não for local\n      const interfaceCompleta = match[0];\n      const complexidade = calculateComplexidade(interfaceCompleta);\n      if (complexidade >= 4 && !isLocal) {\n        const detection: InterfaceInlineDetection = {\n          tipo: 'interface',\n          nome: nomeInterface,\n          linha,\n          complexidade,\n          contexto: interfaceCompleta.substring(0, 100),\n          sugestao: DetectorInterfacesInlineMensagens.interfaceComplexaParaTipos(nomeInterface)\n        };\n        ocorrencias.push(createOcorrencia(detection, relPath));\n      }\n    }\n\n    // 6. Detectar tipos inline repetidos (possível duplicação)\n    const tiposInline = extractAllInlineTypes(src);\n    const tiposRepetidos = findDuplicateTypes(tiposInline);\n    for (const [estrutura, ocorrenciasArray] of tiposRepetidos.entries()) {\n      const totalOcorrencias = ocorrenciasArray.length;\n      const primeiraOcorrencia = ocorrenciasArray[0];\n\n      // Extrair assinatura das propriedades para mensagem\n      const propriedades = estrutura.split(';').map(p => p.split(':')[0]).slice(0, 3);\n      const nomesSugeridos = propriedades.join('_');\n\n      // Detectar contextos de uso\n      const contextosUnicos = [...new Set(ocorrenciasArray.map(o => o.contexto))];\n      const contextoDesc = contextosUnicos.length > 1 ? `em ${contextosUnicos.length} contextos diferentes` : 'no mesmo contexto';\n      ocorrencias.push({\n        tipo: 'interface-inline-duplicada',\n        nivel: 'aviso',\n        mensagem: DetectorInterfacesInlineMensagens.tipoDuplicado({\n          propriedades,\n          totalOcorrencias,\n          contextoDesc,\n          nomesSugeridos\n        }),\n        relPath,\n        linha: primeiraOcorrencia.linha,\n        detalhes: {\n          estrutura,\n          ocorrencias: ocorrenciasArray.length,\n          linhas: ocorrenciasArray.map(o => o.linha),\n          contextos: contextosUnicos\n        }\n      } as Ocorrencia);\n    }\n    return ocorrencias;\n  }\n};\n\n/**\n * Analisa uma interface inline e determina se deve ser extraída\n */\nfunction analyzeInlineInterface(code: string, linha: number, contexto: 'function-return' | 'parameter' | 'variable'): InterfaceInlineDetection | null {\n  const tiposDirDisplay = getTypesDirectoryDisplay();\n  const complexidade = calculateComplexidade(code);\n\n  // Só reportar se for realmente complexo (5+ propriedades)\n  if (complexidade < 5) {\n    return null;\n  }\n  let sugestao = '';\n  switch (contexto) {\n    case 'function-return':\n      sugestao = `Extrair tipo de retorno para interface em ${tiposDirDisplay}`;\n      break;\n    case 'parameter':\n      sugestao = `Extrair tipo de parâmetro para interface em ${tiposDirDisplay}`;\n      break;\n    case 'variable':\n      sugestao = `Extrair tipo da variável para interface em ${tiposDirDisplay}`;\n      break;\n  }\n  return {\n    tipo: 'object-literal-type',\n    linha,\n    complexidade,\n    contexto: code.substring(0, 100),\n    sugestao\n  };\n}\n\n/**\n * Calcula complexidade de um tipo baseado em propriedades, união, interseção, etc\n */\nfunction calculateComplexidade(tipoString: string): number {\n  let score = 0;\n\n  // Contar propriedades: cada `;` ou `,` seguido de algo indica uma propriedade\n  // Também conta `:` para capturar propriedades sem separador final\n  const propriedadesMultilinha = (tipoString.match(/[;:]\\s*\\n/g) || []).length;\n  const propriedadesInline = (tipoString.match(/;\\s*\\w+\\s*:/g) || []).length;\n  const propriedadesTotal = (tipoString.match(/\\w+\\s*\\??\\s*:/g) || []).length;\n\n  // Usar o maior valor entre as contagens (sem fator de redução para inline)\n  score += Math.max(propriedadesMultilinha, propriedadesInline + 1, propriedadesTotal);\n\n  // Contar operadores de união\n  const unioes = (tipoString.match(/\\|/g) || []).length;\n  score += unioes * 0.5;\n\n  // Contar operadores de interseção\n  const intersecoes = (tipoString.match(/&/g) || []).length;\n  score += intersecoes * 0.5;\n\n  // Contar genéricos aninhados\n  const genericosAninhados = (tipoString.match(/<[^>]*</g) || []).length;\n  score += genericosAninhados * 2;\n\n  // Contar arrays e objetos aninhados\n  const aninhamento = (tipoString.match(/{\\s*\\w+\\s*:/g) || []).length;\n  score += aninhamento;\n  return Math.floor(score);\n}\n\n/**\n * Extrai estrutura normalizada de propriedades de um tipo objeto\n */\nfunction extractTypeStructure(tipoString: string): string {\n  // Extrair apenas nomes e tipos das propriedades, ignorando valores específicos\n  const props: string[] = [];\n\n  // Pattern melhorado para capturar propriedades com seus tipos\n  const propPadrao = /(\\w+)\\??\\s*:\\s*([^;,}]+)/g;\n  let match: RegExpMatchArray | null;\n  while ((match = propPadrao.exec(tipoString)) !== null) {\n    const propNome = match[1];\n    let propTipo = match[2].trim();\n\n    // Normalizar tipos comuns\n    propTipo = propTipo.replace(/\\s+/g, ' ').replace(/string|number|boolean|null|undefined/gi, m => m.toLowerCase()).replace(/\\[\\]/g, 'Array').replace(/Record<[^>]+>/g, 'Record').replace(/Promise<[^>]+>/g, 'Promise').trim();\n    props.push(`${propNome}:${propTipo}`);\n  }\n\n  // Retornar assinatura normalizada ordenada\n  return props.sort().join(';');\n}\n\n/**\n * Extrai todos os tipos inline do código com estrutura normalizada\n */\nfunction extractAllInlineTypes(src: string): InlineTypeOccurrence[] {\n  const tipos: InlineTypeOccurrence[] = [];\n\n  // Pattern melhorado para capturar objetos tipo literal (incluindo multi-linha)\n  // Procura por padrões como: { prop: type, ... } em contextos de tipo\n  const lines = src.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    // Detectar início de tipo objeto literal\n    // Contextos: : { ... }, < { ... }, = { ... } (em tipos, não valores)\n    const typeObjInicio = /[:=<]\\s*\\{\\s*$/;\n    const inlineTipoObj = /:\\s*\\{[^}]+\\}/g;\n\n    // Tentar match inline simples primeiro\n    let match: RegExpMatchArray | null;\n    while ((match = inlineTipoObj.exec(line)) !== null) {\n      const matchIndex = match.index ?? 0;\n      const position = src.substring(0, src.indexOf(lines.slice(0, i + 1).join('\\n'))).length + matchIndex;\n      if (!isInStringOrComment(src, position)) {\n        const tipoOriginal = match[0].substring(match[0].indexOf('{'));\n        const complexidade = calculateComplexidade(tipoOriginal);\n        if (complexidade >= 4) {\n          const estrutura = extractTypeStructure(tipoOriginal);\n          const contexto = line.substring(0, matchIndex).trim().substring(0, 60);\n          const linha = i + 1;\n          tipos.push({\n            tipo: tipoOriginal.replace(/\\s+/g, ' ').trim(),\n            estrutura,\n            linha,\n            contexto\n          });\n        }\n      }\n    }\n\n    // Detectar objetos tipo multi-linha\n    if (typeObjInicio.test(line) && !line.includes('//')) {\n      let depth = 1;\n      const tipoLines: string[] = ['{'];\n      let j = i + 1;\n      while (j < lines.length && depth > 0) {\n        const nextLine = lines[j];\n        tipoLines.push(nextLine);\n\n        // Contar abertura/fechamento de chaves (simplificado)\n        for (const char of nextLine) {\n          if (char === '{') depth++;\n          if (char === '}') depth--;\n          if (depth === 0) break;\n        }\n        j++;\n        if (j - i > 50) break; // Limite de segurança\n      }\n      if (depth === 0) {\n        const tipoOriginal = tipoLines.join('\\n').trim();\n        const position = src.indexOf(tipoOriginal);\n        if (position !== -1 && !isInStringOrComment(src, position)) {\n          const complexidade = calculateComplexidade(tipoOriginal);\n          if (complexidade >= 4) {\n            const estrutura = extractTypeStructure(tipoOriginal);\n            const contexto = line.substring(0, line.indexOf('{')).trim().substring(0, 60);\n            const linha = i + 1;\n            tipos.push({\n              tipo: tipoOriginal.replace(/\\s+/g, ' ').trim(),\n              estrutura,\n              linha,\n              contexto\n            });\n          }\n        }\n      }\n    }\n  }\n  return tipos;\n}\n\n/**\n * Encontra tipos inline duplicados com base na estrutura normalizada\n */\ninterface DuplicateEntry {\n  linha: number;\n  tipo: string;\n  contexto: string;\n}\n\nfunction findDuplicateTypes(tipos: InlineTypeOccurrence[]): Map<string, DuplicateEntry[]> {\n  const mapa = new Map<string, DuplicateEntry[]>();\n\n  // Agrupar por estrutura normalizada (não por tipo literal exato)\n  for (const {\n    estrutura,\n    linha,\n    tipo,\n    contexto\n  } of tipos) {\n    if (!mapa.has(estrutura)) {\n      mapa.set(estrutura, []);\n    }\n    const arr = mapa.get(estrutura);\n    if (arr) {\n      arr.push({\n        linha,\n        tipo,\n        contexto\n      });\n    }\n  }\n\n  // Filtrar apenas duplicados significativos\n  const duplicados = new Map<string, DuplicateEntry[]>();\n  for (const [estrutura, ocorrencias] of mapa.entries()) {\n    // Critérios mais refinados:\n    // - >= 4 ocorrências: duplicação clara que deve ser extraída\n    // - >= 3 ocorrências com contextos diferentes: possível tipo comum\n    const contextosUnicos = new Set(ocorrencias.map(o => o.contexto)).size;\n    if (ocorrencias.length >= 4 || ocorrencias.length >= 3 && contextosUnicos >= 2) {\n      duplicados.set(estrutura, ocorrencias);\n    }\n  }\n  return duplicados;\n}\n\n/**\n * Cria ocorrência a partir de uma detecção\n */\nfunction createOcorrencia(detection: InterfaceInlineDetection, relPath: string): Ocorrencia {\n  const tiposDirDisplay = getTypesDirectoryDisplay();\n  let tipo = '';\n  let nivel: 'info' | 'aviso' | 'erro' = 'info';\n  let mensagem = '';\n  switch (detection.tipo) {\n    case 'interface':\n      tipo = 'interface-inline-exportada';\n      nivel = 'aviso';\n      mensagem = detection.nome ? `Interface '${detection.nome}' deve estar em ${tiposDirDisplay}` : `Interface inline deve estar em ${tiposDirDisplay}`;\n      break;\n    case 'type-alias':\n      tipo = 'type-alias-inline-complexo';\n      nivel = 'aviso';\n      mensagem = detection.nome ? `Tipo '${detection.nome}' complexo deve estar em ${tiposDirDisplay}` : `Tipo complexo deve estar em ${tiposDirDisplay}`;\n      break;\n    case 'object-literal-type':\n      tipo = 'tipo-literal-inline-complexo';\n      nivel = 'info';\n      mensagem = `Tipo literal complexo (${detection.complexidade} propriedades) - considere extrair`;\n      break;\n  }\n  return {\n    tipo,\n    nivel,\n    mensagem,\n    relPath,\n    linha: detection.linha\n  } as Ocorrencia;\n} /**\n  * Extrai definição completa de um tipo a partir do ponto após o '='\n  */\nfunction extractTypeDefinition(afterEquals: string): string | null {\n  let depth = 0;\n  let inString = false;\n  let stringChar = '';\n  let result = '';\n  for (let i = 0; i < afterEquals.length; i++) {\n    const char = afterEquals[i];\n    const prevChar = i > 0 ? afterEquals[i - 1] : '';\n\n    // Controle de strings\n    if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n      if (inString && char === stringChar) {\n        inString = false;\n      } else if (!inString) {\n        inString = true;\n        stringChar = char;\n      }\n    }\n    if (inString) {\n      result += char;\n      continue;\n    }\n\n    // Contar chaves\n    if (char === '{' || char === '<' || char === '[' || char === '(') {\n      depth++;\n    } else if (char === '}' || char === '>' || char === ']' || char === ')') {\n      depth--;\n    }\n    result += char;\n\n    // Parar no ponto-e-vírgula no nível raiz\n    if (char === ';' && depth === 0) {\n      return result;\n    }\n  }\n  return null;\n}\n\n/**\n * Verifica se posição está dentro de string ou comentário\n */\nfunction isInStringOrComment(src: string, position: number): boolean {\n  const beforePosition = src.substring(0, position);\n  const linha = beforePosition.split('\\n').pop() || '';\n\n  // Comentário de linha\n  if (linha.includes('//')) {\n    const commentPos = linha.indexOf('//');\n    const posInLine = beforePosition.length - beforePosition.lastIndexOf('\\n') - 1;\n    if (posInLine > commentPos) {\n      return true;\n    }\n  }\n\n  // Comentário de bloco\n  const lastBlockCommentInicio = beforePosition.lastIndexOf('/*');\n  const lastBlockCommentFim = beforePosition.lastIndexOf('*/');\n  if (lastBlockCommentInicio > lastBlockCommentFim) {\n    return true;\n  }\n\n  // String (aspas simples ou duplas)\n  const singleQuotes = (beforePosition.match(/'/g) || []).length;\n  const doubleQuotes = (beforePosition.match(/\"/g) || []).length;\n  const backticks = (beforePosition.match(/`/g) || []).length;\n  return singleQuotes % 2 !== 0 || doubleQuotes % 2 !== 0 || backticks % 2 !== 0;\n}\nexport default ANALISTA;"]}