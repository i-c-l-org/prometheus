{"version":3,"file":"leitor-relatorio.js","sourceRoot":"","sources":["../../../src/shared/helpers/leitor-relatorio.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n/**\n * Utilitários para trabalhar com relatórios JSON versionados\n */\n\nimport { migrarParaVersaoAtual, validarSchema } from '@core/schema/version.js';\nimport { lerEstado } from '@shared/persistence/persistencia.js';\n\nimport type { LeitorRelatorioOptions } from '@';\n\n// Re-exporta o tipo para compatibilidade\nexport type { LeitorRelatorioOptions };\n\ntype RelatorioGenerico = Record<string, unknown>;\ntype RelatorioVersionado<T = unknown> = RelatorioGenerico & {\n  _schema?: Record<string, unknown>;\n  dados?: T;\n};\n\n/**\n * Lê um relatório JSON versionado do disco\n */\nexport async function lerRelatorioVersionado<T = unknown>(\n  options: LeitorRelatorioOptions,\n): Promise<{\n  sucesso: boolean;\n  dados?: T;\n  schema?: Record<string, unknown>;\n  erro?: string;\n  migrado?: boolean;\n}> {\n  const { caminho, validar = true, migrar = false } = options;\n\n  try {\n    // Ler arquivo\n    const conteudo = await lerEstado<Record<string, unknown>>(caminho);\n\n    if (!conteudo) {\n      return {\n        sucesso: false,\n        erro: 'Arquivo não encontrado ou vazio',\n      };\n    }\n\n    let relatorioFinal = conteudo;\n    let migrado = false;\n\n    // Validar schema se solicitado\n    if (validar) {\n      const validacao = validarSchema(conteudo);\n      if (!validacao.valido) {\n        return {\n          sucesso: false,\n          erro: `Schema inválido: ${validacao.erros.join(', ')}`,\n        };\n      }\n    }\n\n    // Migrar se necessário e solicitado.\n    // - Se migrar=true: migramos explicitamente.\n    // - Se migrar=false e validar=false: aceitamos o conteúdo legado como está (modo permissivo).\n    // - Se migrar=false e validar=true: rejeitamos (chamador pediu validação estrita).\n    if (!conteudo._schema || !conteudo.dados) {\n      if (migrar) {\n        relatorioFinal = migrarParaVersaoAtual<unknown>(\n          conteudo,\n        ) as unknown as Record<string, unknown>;\n        migrado = true;\n      } else if (!validar) {\n        // modo permissivo: aceitar o conteúdo legado sem migrar\n        relatorioFinal = conteudo;\n        migrado = false;\n      } else {\n        return {\n          sucesso: false,\n          erro: 'Relatório em formato antigo (sem _schema); habilite migrar para atualizá-lo explicitamente.',\n        };\n      }\n    }\n\n    // Extrair dados: se for relatório versionado, retornamos apenas `dados`.\n    // Se for formato legado (sem _schema), retornamos o objeto inteiro.\n    let dados: T;\n    const relObj = relatorioFinal as RelatorioVersionado<T>;\n\n    if ('_schema' in relObj && relObj._schema) {\n      dados = relObj.dados as T;\n    } else {\n      dados = relatorioFinal as T;\n    }\n\n    return {\n      sucesso: true,\n      dados,\n      schema: (relObj._schema as Record<string, unknown>) || undefined,\n      migrado,\n    };\n  } catch (error) {\n    return {\n      sucesso: false,\n      erro: `Erro ao ler relatório: ${error instanceof Error ? error.message : String(error)}`,\n    };\n  }\n}\n\n/**\n * Lê apenas os dados de um relatório, ignorando metadados de versão\n */\nexport async function lerDadosRelatorio<T = unknown>(\n  caminho: string,\n): Promise<{\n  sucesso: boolean;\n  dados?: T;\n  erro?: string;\n}> {\n  // Para obtenção superficial de dados, permitimos migração automática aqui\n  const resultado = await lerRelatorioVersionado<T>({\n    caminho,\n    validar: false,\n    migrar: true,\n  });\n\n  return {\n    sucesso: resultado.sucesso,\n    dados: resultado.dados,\n    erro: resultado.erro,\n  };\n}\n\n/**\n * Verifica se um relatório tem schema válido\n */\n\nexport async function verificarSchemaRelatorio(caminho: string): Promise<{\n  valido: boolean;\n  versao?: string;\n  erros?: string[];\n  erro?: string;\n}> {\n  try {\n    const conteudo = await lerEstado<Record<string, unknown>>(caminho);\n\n    if (!conteudo) {\n      return {\n        valido: false,\n        erros: ['Arquivo não encontrado ou vazio'],\n      };\n    }\n\n    const validacao = validarSchema(conteudo);\n\n    return {\n      valido: validacao.valido,\n      versao: (conteudo._schema as Record<string, unknown>)?.versao as\n        | string\n        | undefined,\n      erros: validacao.erros,\n    };\n  } catch (error) {\n    return {\n      valido: false,\n      erro: `Erro ao verificar schema: ${error instanceof Error ? error.message : String(error)}`,\n    };\n  }\n}\n"]}