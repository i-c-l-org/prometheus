{"version":3,"file":"imports.js","sourceRoot":"","sources":["../../../src/shared/helpers/imports.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n// @prometheus-disable tipo-literal-inline-complexo\n// Justificativa: tipos locais para reescrita de imports\n/**\n * Helper puro para reescrever imports relativos quando um arquivo é movido.\n * Não toca disco; apenas retorna o novo conteúdo.\n */\nimport path from 'node:path';\n\nimport type { ImportReescrito } from '@';\n\n// Re-exporta o tipo para compatibilidade\nexport type { ImportReescrito };\nexport function reescreverImports(conteudo: string, arquivoDe: string, arquivoPara: string): {\n  novoConteudo: string;\n  reescritos: ImportReescrito[];\n} {\n  // Suporta import/export from e require simples\n  const padrao = /(import\\s+[^'\";]+from\\s*['\"]([^'\"\\n]+)['\"]\\s*;?|export\\s+\\*?\\s*from\\s*['\"]([^'\"\\n]+)['\"];?|require\\(\\s*['\"]([^'\"\\n]+)['\"]\\s*\\))/g;\n  const norm = (p: string) => path.posix.normalize(p.replace(/\\\\/g, '/'));\n  const baseDe = path.posix.dirname(norm(arquivoDe));\n  const basePara = path.posix.dirname(norm(arquivoPara));\n  // raízes calculadas anteriormente não são usadas; mantemos somente baseDe/basePara\n  const reescritos: ImportReescrito[] = [];\n  const novoConteudo = conteudo.replace(padrao, (full, _i1, gFrom, gExport, gReq) => {\n    const spec = gFrom || gExport || gReq;\n    if (!spec) return full;\n    // Só reescreve relativos ou aliases conhecidos do projeto que mapeiam para src/*\n    const isRelative = spec.startsWith('./') || spec.startsWith('../');\n    const isAliasRaiz = spec.startsWith('@/');\n    // Aliases internos do projeto que queremos normalizar para src/<alias>/...\n    // Mantém @nucleo/* intacto (tratado como pacote/externo nos testes)\n    const isProjectAlias = /^@(?:analistas|arquitetos|cli|relatorios|tipos|zeladores)\\//.test(spec);\n    if (!isAliasRaiz && !isProjectAlias && !spec.includes('/src/') && !isRelative) return full;\n    let alvoAntigo: string;\n    if (isAliasRaiz || isProjectAlias || spec.includes('/src/')) {\n      // Normaliza alias para caminho sob 'src/...'\n      let specNormalized = spec;\n      if (isAliasRaiz) specNormalized = specNormalized.replace(/^@\\//, 'src/');else if (isProjectAlias) specNormalized = specNormalized.replace(/^@([^/]+)\\//, 'src/$1/');\n      // extrai sempre o segmento após a primeira ocorrência de 'src/'\n      // lida com spec que comece com 'src/...', '/src/...', '@/...' (convertido para 'src/...')\n      let afterSrc = specNormalized.replace(/^.*src\\//, '');\n      // remove extensão .js caso presente para evitar preservá-la nos relativos\n      afterSrc = afterSrc.replace(/\\.js$/, '');\n      alvoAntigo = norm(path.posix.join('src', afterSrc || ''));\n\n      // Corrige casos onde testes referenciam caminhos improváveis como src/cli/utils/*\n      // Padroniza para src/utils/*, evitando inflar profundidade relativa\n      alvoAntigo = alvoAntigo.replace(/^src\\/cli\\/utils\\//, 'src/utils/').replace(/^src\\/cli\\//, 'src/')\n      // Colapsa o primeiro segmento após src quando for util|utils\n      .replace(/^src\\/[^/]+\\/(?:util|utils)\\//, 'src/utils/');\n      // Evita duplicação utils/utils\n      alvoAntigo = alvoAntigo.replace(/\\/utils\\/utils\\//g, '/utils/');\n    } else {\n      alvoAntigo = norm(path.posix.join(baseDe, spec));\n    }\n    let novoRel = path.posix.relative(basePara, alvoAntigo);\n    // Normaliza separadores e remove duplicações\n    novoRel = path.posix.normalize(novoRel);\n    // Remove extensão .js se ainda existir\n    novoRel = novoRel.replace(/\\.js$/, '');\n    // Garante relativo com ./ ou ../\n    if (!novoRel.startsWith('.')) novoRel = `./${novoRel}`;\n    reescritos.push({\n      from: spec,\n      to: novoRel\n    });\n    return full.replace(spec, novoRel);\n  });\n  return {\n    novoConteudo,\n    reescritos\n  };\n}"]}