{"version":3,"file":"persistencia.js","sourceRoot":"","sources":["../../../src/shared/persistence/persistencia.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT-0\n// @prometheus-disable tipo-inseguro-unknown\n// Justificativa: unknown é usado para serialização genérica que aceita qualquer entrada\nimport { promises as fs } from 'node:fs';\nimport * as fsCb from 'node:fs';\nimport path from 'node:path';\n\nimport { ExcecoesMensagens } from '@core/messages/core/excecoes-messages.js';\n\nimport type { GlobalComVitest, SalvarBinarioFn, SalvarEstadoFn, VitestSpyWrapper } from '@';\n\nconst RAIZ = process.cwd();\nconst IS_TEST = (process.env.VITEST ?? '') !== '';\nfunction safeGet<T extends object, K extends PropertyKey>(obj: T, key: K): unknown {\n  try {\n    // @ts-expect-error acesso dinâmico protegido\n    return obj[key];\n  } catch {\n    return undefined;\n  }\n}\nfunction assertInsideRoot(caminho: string): void {\n  // Permite fora da raiz explicitamente em testes ou quando habilitado\n  // Qualquer valor truthy em VITEST deve liberar a restrição (Vitest define VITEST=\"true\")\n  if ((process.env.VITEST ?? '') !== '' || process.env.PROMETHEUS_ALLOW_OUTSIDE_FS === '1') return;\n  const resolved = path.resolve(caminho);\n  if (!resolved.startsWith(path.resolve(RAIZ))) {\n    throw new Error(ExcecoesMensagens.persistenciaNegadaForaRaizProjeto(caminho));\n  }\n}\ntype JSONValue = string | number | boolean | null | JSONValue[] | {\n  [key: string]: JSONValue;\n};\nfunction sortKeysDeep(v: JSONValue): JSONValue {\n  if (v === null || v === undefined) return v;\n  if (Array.isArray(v)) return v.map(item => sortKeysDeep(item));\n  if (typeof v === 'object') {\n    const configObject = v as Record<string, JSONValue>;\n    const out: Record<string, JSONValue> = {};\n    for (const k of Object.keys(configObject).sort()) out[k] = sortKeysDeep(configObject[k]);\n    return out;\n  }\n  return v;\n}\nfunction stableStringify(dados: unknown): string {\n  // Serialização genérica: aceita entrada arbitrária e converte para JSON válido\n  return JSON.stringify(sortKeysDeep(dados as JSONValue), null, 2);\n}\n\n/**\n * Lê e desserializa um arquivo JSON de estado.\n * Fallback: retorna [] para compatibilidade com formas antigas ou objeto vazio quando apropriado.\n */\nexport async function lerEstado<T = unknown>(caminho: string, padrao?: T): Promise<T> {\n  try {\n    const conteudo = await readFileSafe(caminho, 'utf-8');\n    try {\n      return JSON.parse(conteudo) as T; // sucesso JSON\n    } catch {\n      // Compatibilidade com testes/versões antigas: se JSON inválido retorna []\n      return padrao as T ?? [] as unknown as T;\n    }\n  } catch {\n    return padrao as T ?? [] as unknown as T;\n  }\n}\n\n/** Escrita atômica com permissões restritas e fsync. */\nasync function salvarEstadoImpl<T = unknown>(caminho: string, dados: T): Promise<void> {\n  assertInsideRoot(caminho);\n  const dir = path.dirname(caminho);\n  await mkdirSafe(dir, {\n    recursive: true,\n    mode: 0o700\n  }).catch(() => {});\n  const isString = typeof dados === 'string';\n  const payload = isString ? dados as string : stableStringify(dados);\n  const tempArquivoCaminho = path.join(dir, `.tmp-bin-${Date.now()}-${Math.random().toString(16).slice(2)}.prometheus`);\n  // Escreve diretamente com fs.promises para manter compat em ambientes mockados\n  await writeFileSafe(tempArquivoCaminho, payload, {\n    encoding: 'utf-8',\n    mode: 0o600\n  });\n  await renameSafe(tempArquivoCaminho, caminho);\n}\n\n// Export reatribuível: em testes, será embrulhado por vi.fn para permitir spies em chamadas\nexport let salvarEstado: SalvarEstadoFn = salvarEstadoImpl;\n\n// Em ambiente de testes (Vitest), se disponível global vi.fn, usa wrapper spy\ntry {\n  const maybeVi = (globalThis as GlobalComVitest).vi;\n  if (IS_TEST && maybeVi && typeof maybeVi.fn === 'function') {\n    // Garante que o spy invoque a implementação real por padrão\n    salvarEstado = (maybeVi.fn as unknown as VitestSpyWrapper<SalvarEstadoFn>)(async (...args: [string, unknown]) => salvarEstadoImpl(...(args as [string, unknown]))) as unknown as SalvarEstadoFn;\n  }\n} catch {}\n\n// Leitura bruta de arquivo de texto (sem parse JSON). Uso para conteúdo fonte.\n\nexport async function lerArquivoTexto(caminho: string): Promise<string> {\n  try {\n    return await readFileSafe(caminho, 'utf-8');\n  } catch {\n    return '';\n  }\n}\n\n/** Escrita atômica: grava em tmp e renomeia. */\nexport async function salvarEstadoAtomico<T = unknown>(caminho: string, dados: T): Promise<void> {\n  assertInsideRoot(caminho);\n  const dir = path.dirname(caminho);\n  await mkdirSafe(dir, {\n    recursive: true,\n    mode: 0o700\n  });\n  const tempArquivoCaminho = path.join(dir, `.tmp-${Date.now()}-${Math.random().toString(16).slice(2)}.json`);\n  const payload = stableStringify(dados);\n  await writeFileSafe(tempArquivoCaminho, payload, {\n    encoding: 'utf-8',\n    mode: 0o600\n  });\n  await renameSafe(tempArquivoCaminho, caminho);\n}\n\n/**\n * Escrita binária atômica: grava Buffer em arquivo temporário e renomeia.\n * Usa os mesmos mecanismos resilientes a mocks do restante do módulo.\n */\nexport async function salvarBinarioAtomico(caminho: string, dados: Buffer): Promise<void> {\n  assertInsideRoot(caminho);\n  const dir = path.dirname(caminho);\n  await mkdirSafe(dir, {\n    recursive: true,\n    mode: 0o700\n  });\n  const temporaryValor = path.join(dir, `.tmp-${Date.now()}-${Math.random().toString(16).slice(2)}.bin`);\n\n  // Tenta usar fs.promises.writeFile se disponível para Buffer\n  const p = fs as unknown as {\n    writeFile?: (p: string, d: Buffer | string, o?: {\n      encoding?: BufferEncoding;\n      mode?: number;\n    }) => Promise<void>;\n  };\n  if (typeof p.writeFile === 'function') {\n    await p.writeFile(temporaryValor, dados);\n    await renameSafe(temporaryValor, caminho);\n    return;\n  }\n  const cbWrite = safeGet(fsCb as unknown as {\n    writeFile?: unknown;\n  }, 'writeFile');\n  if (typeof cbWrite === 'function') {\n    await new Promise<void>((resolve, reject) => {\n      (cbWrite as (p: string, d: Buffer, cb: (err: NodeJS.ErrnoException | null) => void) => void)(temporaryValor, dados, err => err ? reject(err) : resolve());\n    });\n    await renameSafe(temporaryValor, caminho);\n    return;\n  }\n  if (IS_TEST) return;\n  throw new Error(ExcecoesMensagens.fsWriteFileBinaryIndisponivel);\n}\n\n// Export reatribuível para permitir spies em testes\nexport let salvarBinario: SalvarBinarioFn = salvarBinarioAtomico;\ntry {\n  const maybeVi2 = (globalThis as GlobalComVitest).vi;\n  if (IS_TEST && maybeVi2 && typeof maybeVi2.fn === 'function') {\n    salvarBinario = (maybeVi2.fn as unknown as VitestSpyWrapper<SalvarBinarioFn>)(async (...args: [string, Buffer]) => salvarBinarioAtomico(...args)) as unknown as SalvarBinarioFn;\n  }\n} catch {}\n\n// --- Fallbacks resilientes a mocks parciais de fs.promises ---\n\nasync function readFileSafe(pathname: string, encoding?: BufferEncoding): Promise<string> {\n  const p = fs as unknown as {\n    readFile?: (p: string, e: BufferEncoding) => Promise<string>;\n  };\n  if (typeof p.readFile === 'function') {\n    return await p.readFile(pathname, encoding ?? 'utf-8');\n  }\n  // Callback API fallback\n  const cbRead = safeGet(fsCb as unknown as {\n    readFile?: unknown;\n  }, 'readFile');\n  if (typeof cbRead === 'function') {\n    return await new Promise<string>((resolve, reject) => {\n      (cbRead as (p: string, e: BufferEncoding, cb: (err: NodeJS.ErrnoException | null, data: string) => void) => void)(pathname, encoding ?? 'utf-8', (err, data) => {\n        if (err) reject(err);else resolve(data);\n      });\n    });\n  }\n  // Em ambiente de teste com mock total de fs, deixe o caller lidar via try/catch\n  throw new Error(ExcecoesMensagens.fsReadFileIndisponivel);\n}\nasync function writeFileSafe(pathname: string, data: string, options?: {\n  encoding?: BufferEncoding;\n  mode?: number;\n}): Promise<void> {\n  const p = fs as unknown as {\n    writeFile?: (p: string, d: string, o?: {\n      encoding?: BufferEncoding;\n      mode?: number;\n    }) => Promise<void>;\n  };\n  if (typeof p.writeFile === 'function') {\n    await p.writeFile(pathname, data, options);\n    return;\n  }\n  // Callback API fallback\n  const cbWrite = safeGet(fsCb as unknown as {\n    writeFile?: unknown;\n  }, 'writeFile');\n  if (typeof cbWrite === 'function') {\n    await new Promise<void>((resolve, reject) => {\n      (cbWrite as (p: string, d: string, o: {\n        encoding?: BufferEncoding;\n        mode?: number;\n      } | undefined, cb: (err: NodeJS.ErrnoException | null) => void) => void)(pathname, data, options, err => err ? reject(err) : resolve());\n    });\n    return;\n  }\n  // Em testes com fs totalmente mockado, considere no-op para escrita\n  if (IS_TEST) return;\n  throw new Error(ExcecoesMensagens.fsWriteFileIndisponivel);\n}\nasync function renameSafe(oldPath: string, newPath: string): Promise<void> {\n  const p = fs as unknown as {\n    rename?: (o: string, n: string) => Promise<void>;\n  };\n  if (typeof p.rename === 'function') {\n    await p.rename(oldPath, newPath);\n    return;\n  }\n  const cbRename = safeGet(fsCb as unknown as {\n    rename?: unknown;\n  }, 'rename');\n  if (typeof cbRename === 'function') {\n    await new Promise<void>((resolve, reject) => {\n      (cbRename as (o: string, n: string, cb: (err: NodeJS.ErrnoException | null) => void) => void)(oldPath, newPath, err => err ? reject(err) : resolve());\n    });\n    return;\n  }\n  if (IS_TEST) return;\n  throw new Error(ExcecoesMensagens.fsRenameIndisponivel);\n}\nasync function mkdirSafe(dirPath: string, options?: {\n  recursive?: boolean;\n  mode?: number;\n}): Promise<void> {\n  const p = fs as unknown as {\n    mkdir?: (p: string, o?: {\n      recursive?: boolean;\n      mode?: number;\n    }) => Promise<void>;\n  };\n  if (typeof p.mkdir === 'function') {\n    await p.mkdir(dirPath, options);\n    return;\n  }\n  const cbMkdir = safeGet(fsCb as unknown as {\n    mkdir?: unknown;\n  }, 'mkdir');\n  if (typeof cbMkdir === 'function') {\n    await new Promise<void>((resolve, reject) => {\n      (cbMkdir as (p: string, o: {\n        recursive?: boolean;\n        mode?: number;\n      } | undefined, cb: (err: NodeJS.ErrnoException | null) => void) => void)(dirPath, options, err => err ? reject(err) : resolve());\n    });\n    return;\n  }\n  if (IS_TEST) return;\n  throw new Error(ExcecoesMensagens.fsMkdirIndisponivel);\n}"]}